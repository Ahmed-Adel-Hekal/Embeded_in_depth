
Lect5.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000000c0  00000000  00000000  000000f4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00800060  000000c0  000001cb  2**0
                  ALLOC
  2 .bss          00000006  00800060  00800060  00002340  2**0
                  ALLOC
  3 .comment      0000002f  00000000  00000000  00002340  2**0
                  CONTENTS, READONLY
  4 .stack.descriptors.hdr 00000046  00000000  00000000  0000236f  2**0
                  CONTENTS, READONLY
  5 .debug_aranges 000004c8  00000000  00000000  000023b5  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00007c90  00000000  00000000  0000287d  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00001317  00000000  00000000  0000a50d  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000030a3  00000000  00000000  0000b824  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000fa4  00000000  00000000  0000e8c8  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000096f  00000000  00000000  0000f86c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00005edd  00000000  00000000  000101db  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000004e8  00000000  00000000  000160b8  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .text         00000004  0000223c  0000223c  00002330  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 14 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  000165a0  2**2
                  CONTENTS, READONLY, DEBUGGING
 15 .text.pvPortMalloc 00000074  0000187a  0000187a  0000196e  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 16 .text.vPortFree 00000002  00002244  00002244  00002338  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 17 .bss.pucAlignedHeap.2094 00000002  008006a5  008006a5  00002340  2**0
                  ALLOC
 18 .bss.xNextFreeByte 00000002  008006a7  008006a7  00002340  2**0
                  ALLOC
 19 .bss.ucHeap   000005dc  00800066  00800066  00002340  2**0
                  ALLOC
 20 .text.HLCD_vsendData 00000068  000019c8  000019c8  00001abc  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 21 .text.HLCD_vShowInt 000000c2  00000e9e  00000e9e  00000f92  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 22 .text.HLCD_vsendCommand 00000068  00001a30  00001a30  00001b24  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 23 .text.HLCD_vShowString 00000042  00001e5c  00001e5c  00001f50  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 24 .text.HLCD_vInit 00000076  00001804  00001804  000018f8  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 25 .text.vListInitialise 0000001c  00002138  00002138  0000222c  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 26 .text.vListInitialiseItem 00000008  0000221a  0000221a  0000230e  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 27 .text.vListInsert 00000062  00001afe  00001afe  00001bf2  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 28 .text.uxListRemove 0000004e  00001d7a  00001d7a  00001e6e  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 29 .progmemx.data 00000017  000000c0  000000c0  000001b4  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, PROGMEMX
 30 .text.OneshotTask 0000000c  000021ec  000021ec  000022e0  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 31 .text.AutoReloadTask 0000000a  00002210  00002210  00002304  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 32 .text.main    000000a2  000012f0  000012f0  000013e4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 33 .text.prvSetupTimerInterrupt 00000012  000021ca  000021ca  000022be  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 34 .text.pxPortInitialiseStack 000000d8  00000dc6  00000dc6  00000eba  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 35 .text.xPortStartScheduler 0000005e  00001bc2  00001bc2  00001cb6  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 36 .text.vPortYield 000000b2  00001196  00001196  0000128a  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 37 .text.vPortYieldFromTick 000000b8  000010de  000010de  000011d2  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 38 .text.__vector_7 00000006  0000222a  0000222a  0000231e  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 39 .text.prvIsQueueEmpty 00000026  000020b2  000020b2  000021a6  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 40 .text.prvIsQueueFull 00000038  00001f56  00001f56  0000204a  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 41 .text.prvCopyDataToQueue 00000092  000014c6  000014c6  000015ba  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 42 .text.prvCopyDataFromQueue 00000036  00001fc6  00001fc6  000020ba  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 43 .text.prvNotifyQueueSetContainer 00000098  0000142e  0000142e  00001522  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 44 .text.prvUnlockQueue 0000008a  0000167a  0000167a  0000176e  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 45 .text.xQueueGenericReset 000000c2  00000f60  00000f60  00001054  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 46 .text.prvInitialiseNewQueue 00000032  00001ffc  00001ffc  000020f0  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 47 .text.xQueueGenericCreate 00000082  00001704  00001704  000017f8  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 48 .text.xQueueGenericSend 00000154  00000648  00000648  0000073c  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 49 .text.xQueueGenericSendFromISR 000000bc  00001022  00001022  00001116  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 50 .text.xQueueReceive 00000126  000008dc  000008dc  000009d0  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 51 .text.vQueueWaitForMessageRestricted 0000003a  00001f1c  00001f1c  00002010  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 52 .text.prvResetNextTaskUnblockTime 00000038  00001f8e  00001f8e  00002082  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 53 .text.prvDeleteTCB 0000001a  00002170  00002170  00002264  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 54 .text.prvInitialiseNewTask 000000ea  00000bfe  00000bfe  00000cf2  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 55 .text.prvInitialiseTaskLists 0000006e  000018ee  000018ee  000019e2  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 56 .text.prvAddNewTaskToReadyList 000000fa  00000b04  00000b04  00000bf8  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 57 .text.prvCheckTasksWaitingTermination 0000004c  00001dc8  00001dc8  00001ebc  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 58 .text.prvIdleTask 00000006  00002230  00002230  00002324  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 59 .text.prvAddCurrentTaskToDelayedList 00000102  00000a02  00000a02  00000af6  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 60 .text.xTaskCreate 000000de  00000ce8  00000ce8  00000ddc  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 61 .progmemx.data 00000006  000000df  000000df  000001d3  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, PROGMEMX
 62 .text.vTaskStartScheduler 00000066  00001a98  00001a98  00001b8c  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 63 .text.vTaskSuspendAll 0000000c  000021f8  000021f8  000022ec  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 64 .text.xTaskGetTickCount 00000014  000021b6  000021b6  000022aa  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 65 .text.uxTaskGetNumberOfTasks 00000006  00002236  00002236  0000232a  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 66 .text.xTaskIncrementTick 00000234  000000e6  000000e6  000001da  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 67 .text.xTaskResumeAll 000001aa  0000031a  0000031a  0000040e  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 68 .text.vTaskSwitchContext 000000a8  00001248  00001248  0000133c  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 69 .text.vTaskPlaceOnEventList 00000024  000020d8  000020d8  000021cc  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 70 .text.vTaskPlaceOnEventListRestricted 00000092  00001558  00001558  0000164c  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 71 .text.xTaskRemoveFromEventList 00000184  000004c4  000004c4  000005b8  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 72 .text.vTaskInternalSetTimeOutState 00000016  0000218a  0000218a  0000227e  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 73 .text.xTaskCheckForTimeOut 0000007e  00001786  00001786  0000187a  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 74 .text.vTaskMissedYield 00000008  00002222  00002222  00002316  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 75 .text.xTaskGetSchedulerState 0000001c  00002154  00002154  00002248  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 76 .bss.uxSchedulerSuspended 00000001  008006c1  008006c1  00002340  2**0
                  ALLOC
 77 .bss.xIdleTaskHandle 00000002  008006a9  008006a9  00002340  2**0
                  ALLOC
 78 .bss.xNextTaskUnblockTime 00000002  008006ab  008006ab  00002340  2**0
                  ALLOC
 79 .bss.uxTaskNumber 00000001  008006c2  008006c2  00002340  2**0
                  ALLOC
 80 .bss.xNumOfOverflows 00000001  008006c3  008006c3  00002340  2**0
                  ALLOC
 81 .bss.xYieldPending 00000001  008006c4  008006c4  00002340  2**0
                  ALLOC
 82 .bss.xPendedTicks 00000002  008006ad  008006ad  00002340  2**0
                  ALLOC
 83 .bss.xSchedulerRunning 00000001  008006c5  008006c5  00002340  2**0
                  ALLOC
 84 .bss.uxTopReadyPriority 00000001  008006c6  008006c6  00002340  2**0
                  ALLOC
 85 .bss.xTickCount 00000002  008006af  008006af  00002340  2**0
                  ALLOC
 86 .bss.uxCurrentNumberOfTasks 00000001  008006c7  008006c7  00002340  2**0
                  ALLOC
 87 .bss.xSuspendedTaskList 00000009  00800666  00800666  00002340  2**0
                  ALLOC
 88 .bss.uxDeletedTasksWaitingCleanUp 00000001  008006c8  008006c8  00002340  2**0
                  ALLOC
 89 .bss.xTasksWaitingTermination 00000009  0080066f  0080066f  00002340  2**0
                  ALLOC
 90 .bss.xPendingReadyList 00000009  00800678  00800678  00002340  2**0
                  ALLOC
 91 .bss.pxOverflowDelayedTaskList 00000002  008006b1  008006b1  00002340  2**0
                  ALLOC
 92 .bss.pxDelayedTaskList 00000002  008006b3  008006b3  00002340  2**0
                  ALLOC
 93 .bss.xDelayedTaskList2 00000009  00800681  00800681  00002340  2**0
                  ALLOC
 94 .bss.xDelayedTaskList1 00000009  0080068a  0080068a  00002340  2**0
                  ALLOC
 95 .bss.pxReadyTasksLists 00000024  00800642  00800642  00002340  2**0
                  ALLOC
 96 .bss.pxCurrentTCB 00000002  008006b5  008006b5  00002340  2**0
                  ALLOC
 97 .text.prvGetNextExpireTime 0000002a  00002060  00002060  00002154  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 98 .text.prvInsertTimerInActiveList 0000005e  00001c20  00001c20  00001d14  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 99 .text.prvReloadTimer 00000048  00001e14  00001e14  00001f08  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
100 .text.prvProcessExpiredTimer 00000056  00001c7e  00001c7e  00001d72  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
101 .text.prvSwitchTimerLists 0000003c  00001ee0  00001ee0  00001fd4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
102 .text.prvSampleTimeNow 00000042  00001e9e  00001e9e  00001f92  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
103 .text.prvProcessTimerOrBlockTask 00000090  000015ea  000015ea  000016de  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
104 .text.prvProcessReceivedCommands 00000140  0000079c  0000079c  00000890  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
105 .text.prvTimerTask 0000001e  000020fc  000020fc  000021f0  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
106 .text.prvCheckForValidListAndQueue 00000052  00001d28  00001d28  00001e1c  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
107 .text.prvInitialiseNewTimer 0000006c  0000195c  0000195c  00001a50  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
108 .progmemx.data 00000008  000000d7  000000d7  000001cb  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, PROGMEMX
109 .text.xTimerCreateTimerTask 00000054  00001cd4  00001cd4  00001dc8  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
110 .text.xTimerCreate 00000062  00001b60  00001b60  00001c54  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
111 .text.xTimerGenericCommand 0000009c  00001392  00001392  00001486  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
112 .bss.xLastTime.2410 00000002  008006b7  008006b7  00002340  2**0
                  ALLOC
113 .bss.xTimerTaskHandle 00000002  008006b9  008006b9  00002340  2**0
                  ALLOC
114 .bss.xTimerQueue 00000002  008006bb  008006bb  00002340  2**0
                  ALLOC
115 .bss.pxOverflowTimerList 00000002  008006bd  008006bd  00002340  2**0
                  ALLOC
116 .bss.pxCurrentTimerList 00000002  008006bf  008006bf  00002340  2**0
                  ALLOC
117 .bss.xActiveTimerList2 00000009  00800693  00800693  00002340  2**0
                  ALLOC
118 .bss.xActiveTimerList1 00000009  0080069c  0080069c  00002340  2**0
                  ALLOC
119 .text.libgcc.div 00000028  0000208a  0000208a  0000217e  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
120 .text.libgcc  0000000c  00002204  00002204  000022f8  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
121 .text.libgcc.mul 0000001e  0000211a  0000211a  0000220e  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
122 .text.libgcc  00000010  000021dc  000021dc  000022d0  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
123 .text.__dummy_fini 00000002  00002246  00002246  0000233a  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
124 .text.__dummy_funcs_on_exit 00000002  00002248  00002248  0000233c  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
125 .text.__dummy_simulator_exit 00000002  0000224a  0000224a  0000233e  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
126 .text.exit    00000016  000021a0  000021a0  00002294  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
127 .text.memcpy  00000032  0000202e  0000202e  00002122  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
128 .text._Exit   00000004  00002240  00002240  00002334  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 36 00 	jmp	0x6c	; 0x6c <__ctors_end>
   4:	0c 94 1e 11 	jmp	0x223c	; 0x223c <__bad_interrupt>
   8:	0c 94 1e 11 	jmp	0x223c	; 0x223c <__bad_interrupt>
   c:	0c 94 1e 11 	jmp	0x223c	; 0x223c <__bad_interrupt>
  10:	0c 94 1e 11 	jmp	0x223c	; 0x223c <__bad_interrupt>
  14:	0c 94 1e 11 	jmp	0x223c	; 0x223c <__bad_interrupt>
  18:	0c 94 1e 11 	jmp	0x223c	; 0x223c <__bad_interrupt>
  1c:	0c 94 15 11 	jmp	0x222a	; 0x222a <__vector_7>
  20:	0c 94 1e 11 	jmp	0x223c	; 0x223c <__bad_interrupt>
  24:	0c 94 1e 11 	jmp	0x223c	; 0x223c <__bad_interrupt>
  28:	0c 94 1e 11 	jmp	0x223c	; 0x223c <__bad_interrupt>
  2c:	0c 94 1e 11 	jmp	0x223c	; 0x223c <__bad_interrupt>
  30:	0c 94 1e 11 	jmp	0x223c	; 0x223c <__bad_interrupt>
  34:	0c 94 1e 11 	jmp	0x223c	; 0x223c <__bad_interrupt>
  38:	0c 94 1e 11 	jmp	0x223c	; 0x223c <__bad_interrupt>
  3c:	0c 94 1e 11 	jmp	0x223c	; 0x223c <__bad_interrupt>
  40:	0c 94 1e 11 	jmp	0x223c	; 0x223c <__bad_interrupt>
  44:	0c 94 1e 11 	jmp	0x223c	; 0x223c <__bad_interrupt>
  48:	0c 94 1e 11 	jmp	0x223c	; 0x223c <__bad_interrupt>
  4c:	0c 94 1e 11 	jmp	0x223c	; 0x223c <__bad_interrupt>
  50:	0c 94 1e 11 	jmp	0x223c	; 0x223c <__bad_interrupt>
  54:	00 04       	cpc	r0, r0
  56:	00 04       	cpc	r0, r0
  58:	2f 04       	cpc	r2, r15
  5a:	34 04       	cpc	r3, r4
  5c:	4a 04       	cpc	r4, r10
  5e:	00 04       	cpc	r0, r0
  60:	00 04       	cpc	r0, r0
  62:	2f 04       	cpc	r2, r15
  64:	34 04       	cpc	r3, r4

00000066 <.dinit>:
  66:	00 60       	ori	r16, 0x00	; 0
  68:	06 c9       	rjmp	.-3572   	; 0xfffff276 <__eeprom_end+0xff7ef276>
  6a:	80 00       	.word	0x0080	; ????

0000006c <__ctors_end>:
  6c:	11 24       	eor	r1, r1
  6e:	1f be       	out	0x3f, r1	; 63
  70:	cf e5       	ldi	r28, 0x5F	; 95
  72:	d8 e0       	ldi	r29, 0x08	; 8
  74:	de bf       	out	0x3e, r29	; 62
  76:	cd bf       	out	0x3d, r28	; 61

00000078 <__do_copy_data>:
  78:	e6 e6       	ldi	r30, 0x66	; 102
  7a:	f0 e0       	ldi	r31, 0x00	; 0
  7c:	40 e0       	ldi	r20, 0x00	; 0
  7e:	17 c0       	rjmp	.+46     	; 0xae <__do_clear_bss+0x8>
  80:	b5 91       	lpm	r27, Z+
  82:	a5 91       	lpm	r26, Z+
  84:	35 91       	lpm	r19, Z+
  86:	25 91       	lpm	r18, Z+
  88:	05 91       	lpm	r16, Z+
  8a:	07 fd       	sbrc	r16, 7
  8c:	0c c0       	rjmp	.+24     	; 0xa6 <__do_clear_bss>
  8e:	95 91       	lpm	r25, Z+
  90:	85 91       	lpm	r24, Z+
  92:	ef 01       	movw	r28, r30
  94:	f9 2f       	mov	r31, r25
  96:	e8 2f       	mov	r30, r24
  98:	05 90       	lpm	r0, Z+
  9a:	0d 92       	st	X+, r0
  9c:	a2 17       	cp	r26, r18
  9e:	b3 07       	cpc	r27, r19
  a0:	d9 f7       	brne	.-10     	; 0x98 <__do_copy_data+0x20>
  a2:	fe 01       	movw	r30, r28
  a4:	04 c0       	rjmp	.+8      	; 0xae <__do_clear_bss+0x8>

000000a6 <__do_clear_bss>:
  a6:	1d 92       	st	X+, r1
  a8:	a2 17       	cp	r26, r18
  aa:	b3 07       	cpc	r27, r19
  ac:	e1 f7       	brne	.-8      	; 0xa6 <__do_clear_bss>
  ae:	eb 36       	cpi	r30, 0x6B	; 107
  b0:	f4 07       	cpc	r31, r20
  b2:	31 f7       	brne	.-52     	; 0x80 <__do_copy_data+0x8>
  b4:	0e 94 78 09 	call	0x12f0	; 0x12f0 <main>
  b8:	0c 94 d0 10 	jmp	0x21a0	; 0x21a0 <exit>

000000bc <_exit>:
  bc:	f8 94       	cli

000000be <__stop_program>:
  be:	ff cf       	rjmp	.-2      	; 0xbe <__stop_program>

Disassembly of section .text:

0000223c <__bad_interrupt>:
    223c:	0c 94 00 00 	jmp	0	; 0x0 <__TEXT_REGION_ORIGIN__>

Disassembly of section .text.pvPortMalloc:

0000187a <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void * pvPortMalloc( size_t xWantedSize )
{
    187a:	cf 93       	push	r28
    187c:	df 93       	push	r29
    187e:	ec 01       	movw	r28, r24
            }
        }
    }
    #endif /* if ( portBYTE_ALIGNMENT != 1 ) */

    vTaskSuspendAll();
    1880:	0e 94 fc 10 	call	0x21f8	; 0x21f8 <vTaskSuspendAll>
    {
        if( pucAlignedHeap == NULL )
    1884:	80 91 a5 06 	lds	r24, 0x06A5	; 0x8006a5 <pucAlignedHeap.2094>
    1888:	90 91 a6 06 	lds	r25, 0x06A6	; 0x8006a6 <pucAlignedHeap.2094+0x1>
    188c:	89 2b       	or	r24, r25
    188e:	31 f4       	brne	.+12     	; 0x189c <pvPortMalloc+0x22>
        {
            /* Ensure the heap starts on a correctly aligned boundary. */
            pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) & ucHeap[ portBYTE_ALIGNMENT - 1 ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
    1890:	86 e6       	ldi	r24, 0x66	; 102
    1892:	90 e0       	ldi	r25, 0x00	; 0
    1894:	90 93 a6 06 	sts	0x06A6, r25	; 0x8006a6 <pucAlignedHeap.2094+0x1>
    1898:	80 93 a5 06 	sts	0x06A5, r24	; 0x8006a5 <pucAlignedHeap.2094>
        }

        /* Check there is enough room left for the allocation and. */
        if( ( xWantedSize > 0 ) &&                                /* valid size */
    189c:	20 97       	sbiw	r28, 0x00	; 0
    189e:	c9 f0       	breq	.+50     	; 0x18d2 <pvPortMalloc+0x58>
            ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
    18a0:	80 91 a7 06 	lds	r24, 0x06A7	; 0x8006a7 <xNextFreeByte>
    18a4:	90 91 a8 06 	lds	r25, 0x06A8	; 0x8006a8 <xNextFreeByte+0x1>
    18a8:	9e 01       	movw	r18, r28
    18aa:	28 0f       	add	r18, r24
    18ac:	39 1f       	adc	r19, r25
            /* Ensure the heap starts on a correctly aligned boundary. */
            pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) & ucHeap[ portBYTE_ALIGNMENT - 1 ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
        }

        /* Check there is enough room left for the allocation and. */
        if( ( xWantedSize > 0 ) &&                                /* valid size */
    18ae:	2b 3d       	cpi	r18, 0xDB	; 219
    18b0:	45 e0       	ldi	r20, 0x05	; 5
    18b2:	34 07       	cpc	r19, r20
    18b4:	88 f4       	brcc	.+34     	; 0x18d8 <pvPortMalloc+0x5e>
            ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
    18b6:	82 17       	cp	r24, r18
    18b8:	93 07       	cpc	r25, r19
    18ba:	88 f4       	brcc	.+34     	; 0x18de <pvPortMalloc+0x64>
            ( ( xNextFreeByte + xWantedSize ) > xNextFreeByte ) ) /* Check for overflow. */
        {
            /* Return the next free byte then increment the index past this
             * block. */
            pvReturn = pucAlignedHeap + xNextFreeByte;
    18bc:	c0 91 a5 06 	lds	r28, 0x06A5	; 0x8006a5 <pucAlignedHeap.2094>
    18c0:	d0 91 a6 06 	lds	r29, 0x06A6	; 0x8006a6 <pucAlignedHeap.2094+0x1>
    18c4:	c8 0f       	add	r28, r24
    18c6:	d9 1f       	adc	r29, r25
            xNextFreeByte += xWantedSize;
    18c8:	30 93 a8 06 	sts	0x06A8, r19	; 0x8006a8 <xNextFreeByte+0x1>
    18cc:	20 93 a7 06 	sts	0x06A7, r18	; 0x8006a7 <xNextFreeByte>
    18d0:	08 c0       	rjmp	.+16     	; 0x18e2 <pvPortMalloc+0x68>

/*-----------------------------------------------------------*/

void * pvPortMalloc( size_t xWantedSize )
{
    void * pvReturn = NULL;
    18d2:	c0 e0       	ldi	r28, 0x00	; 0
    18d4:	d0 e0       	ldi	r29, 0x00	; 0
    18d6:	05 c0       	rjmp	.+10     	; 0x18e2 <pvPortMalloc+0x68>
    18d8:	c0 e0       	ldi	r28, 0x00	; 0
    18da:	d0 e0       	ldi	r29, 0x00	; 0
    18dc:	02 c0       	rjmp	.+4      	; 0x18e2 <pvPortMalloc+0x68>
    18de:	c0 e0       	ldi	r28, 0x00	; 0
    18e0:	d0 e0       	ldi	r29, 0x00	; 0
            xNextFreeByte += xWantedSize;
        }

        traceMALLOC( pvReturn, xWantedSize );
    }
    ( void ) xTaskResumeAll();
    18e2:	0e 94 8d 01 	call	0x31a	; 0x31a <xTaskResumeAll>
        }
    }
    #endif

    return pvReturn;
}
    18e6:	ce 01       	movw	r24, r28
    18e8:	df 91       	pop	r29
    18ea:	cf 91       	pop	r28
    18ec:	08 95       	ret

Disassembly of section .text.vPortFree:

00002244 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void * pv )
{
    2244:	08 95       	ret

Disassembly of section .text.HLCD_vsendData:

000019c8 <HLCD_vsendData>:
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    19c8:	9b b3       	in	r25, 0x1b	; 27
    19ca:	9f 70       	andi	r25, 0x0F	; 15
    19cc:	28 2f       	mov	r18, r24
    19ce:	20 7f       	andi	r18, 0xF0	; 240
    19d0:	92 2b       	or	r25, r18
    19d2:	9b bb       	out	0x1b, r25	; 27
    19d4:	98 b3       	in	r25, 0x18	; 24
    19d6:	92 60       	ori	r25, 0x02	; 2
    19d8:	98 bb       	out	0x18, r25	; 24
    19da:	98 b3       	in	r25, 0x18	; 24
    19dc:	9b 7f       	andi	r25, 0xFB	; 251
    19de:	98 bb       	out	0x18, r25	; 24
    19e0:	98 b3       	in	r25, 0x18	; 24
    19e2:	98 60       	ori	r25, 0x08	; 8
    19e4:	98 bb       	out	0x18, r25	; 24
    19e6:	ef e9       	ldi	r30, 0x9F	; 159
    19e8:	ff e0       	ldi	r31, 0x0F	; 15
    19ea:	31 97       	sbiw	r30, 0x01	; 1
    19ec:	f1 f7       	brne	.-4      	; 0x19ea <HLCD_vsendData+0x22>
    19ee:	00 c0       	rjmp	.+0      	; 0x19f0 <HLCD_vsendData+0x28>
    19f0:	00 00       	nop
    19f2:	98 b3       	in	r25, 0x18	; 24
    19f4:	97 7f       	andi	r25, 0xF7	; 247
    19f6:	98 bb       	out	0x18, r25	; 24
    19f8:	2b b3       	in	r18, 0x1b	; 27
    19fa:	f0 e1       	ldi	r31, 0x10	; 16
    19fc:	8f 9f       	mul	r24, r31
    19fe:	c0 01       	movw	r24, r0
    1a00:	11 24       	eor	r1, r1
    1a02:	92 2f       	mov	r25, r18
    1a04:	9f 70       	andi	r25, 0x0F	; 15
    1a06:	89 2b       	or	r24, r25
    1a08:	8b bb       	out	0x1b, r24	; 27
    1a0a:	88 b3       	in	r24, 0x18	; 24
    1a0c:	82 60       	ori	r24, 0x02	; 2
    1a0e:	88 bb       	out	0x18, r24	; 24
    1a10:	88 b3       	in	r24, 0x18	; 24
    1a12:	8b 7f       	andi	r24, 0xFB	; 251
    1a14:	88 bb       	out	0x18, r24	; 24
    1a16:	88 b3       	in	r24, 0x18	; 24
    1a18:	88 60       	ori	r24, 0x08	; 8
    1a1a:	88 bb       	out	0x18, r24	; 24
    1a1c:	8f e9       	ldi	r24, 0x9F	; 159
    1a1e:	9f e0       	ldi	r25, 0x0F	; 15
    1a20:	01 97       	sbiw	r24, 0x01	; 1
    1a22:	f1 f7       	brne	.-4      	; 0x1a20 <HLCD_vsendData+0x58>
    1a24:	00 c0       	rjmp	.+0      	; 0x1a26 <HLCD_vsendData+0x5e>
    1a26:	00 00       	nop
    1a28:	88 b3       	in	r24, 0x18	; 24
    1a2a:	87 7f       	andi	r24, 0xF7	; 247
    1a2c:	88 bb       	out	0x18, r24	; 24
    1a2e:	08 95       	ret

Disassembly of section .text.HLCD_vShowInt:

00000e9e <HLCD_vShowInt>:
 e9e:	1f 93       	push	r17
 ea0:	cf 93       	push	r28
 ea2:	df 93       	push	r29
 ea4:	cd b7       	in	r28, 0x3d	; 61
 ea6:	de b7       	in	r29, 0x3e	; 62
 ea8:	2a 97       	sbiw	r28, 0x0a	; 10
 eaa:	0f b6       	in	r0, 0x3f	; 63
 eac:	f8 94       	cli
 eae:	de bf       	out	0x3e, r29	; 62
 eb0:	0f be       	out	0x3f, r0	; 63
 eb2:	cd bf       	out	0x3d, r28	; 61
 eb4:	ac 01       	movw	r20, r24
 eb6:	89 2b       	or	r24, r25
 eb8:	89 f5       	brne	.+98     	; 0xf1c <HLCD_vShowInt+0x7e>
 eba:	45 c0       	rjmp	.+138    	; 0xf46 <HLCD_vShowInt+0xa8>
 ebc:	9a 01       	movw	r18, r20
 ebe:	ad ec       	ldi	r26, 0xCD	; 205
 ec0:	bc ec       	ldi	r27, 0xCC	; 204
 ec2:	0e 94 8d 10 	call	0x211a	; 0x211a <__umulhisi3>
 ec6:	96 95       	lsr	r25
 ec8:	87 95       	ror	r24
 eca:	96 95       	lsr	r25
 ecc:	87 95       	ror	r24
 ece:	96 95       	lsr	r25
 ed0:	87 95       	ror	r24
 ed2:	9c 01       	movw	r18, r24
 ed4:	22 0f       	add	r18, r18
 ed6:	33 1f       	adc	r19, r19
 ed8:	88 0f       	add	r24, r24
 eda:	99 1f       	adc	r25, r25
 edc:	88 0f       	add	r24, r24
 ede:	99 1f       	adc	r25, r25
 ee0:	88 0f       	add	r24, r24
 ee2:	99 1f       	adc	r25, r25
 ee4:	82 0f       	add	r24, r18
 ee6:	93 1f       	adc	r25, r19
 ee8:	9a 01       	movw	r18, r20
 eea:	28 1b       	sub	r18, r24
 eec:	39 0b       	sbc	r19, r25
 eee:	c9 01       	movw	r24, r18
 ef0:	e1 e0       	ldi	r30, 0x01	; 1
 ef2:	f0 e0       	ldi	r31, 0x00	; 0
 ef4:	ec 0f       	add	r30, r28
 ef6:	fd 1f       	adc	r31, r29
 ef8:	e1 0f       	add	r30, r17
 efa:	f1 1d       	adc	r31, r1
 efc:	17 fd       	sbrc	r17, 7
 efe:	fa 95       	dec	r31
 f00:	80 5d       	subi	r24, 0xD0	; 208
 f02:	80 83       	st	Z, r24
 f04:	9a 01       	movw	r18, r20
 f06:	0e 94 8d 10 	call	0x211a	; 0x211a <__umulhisi3>
 f0a:	ac 01       	movw	r20, r24
 f0c:	56 95       	lsr	r21
 f0e:	47 95       	ror	r20
 f10:	56 95       	lsr	r21
 f12:	47 95       	ror	r20
 f14:	56 95       	lsr	r21
 f16:	47 95       	ror	r20
 f18:	1f 5f       	subi	r17, 0xFF	; 255
 f1a:	01 c0       	rjmp	.+2      	; 0xf1e <HLCD_vShowInt+0x80>
 f1c:	10 e0       	ldi	r17, 0x00	; 0
 f1e:	41 15       	cp	r20, r1
 f20:	51 05       	cpc	r21, r1
 f22:	61 f6       	brne	.-104    	; 0xebc <HLCD_vShowInt+0x1e>
 f24:	11 50       	subi	r17, 0x01	; 1
 f26:	0c c0       	rjmp	.+24     	; 0xf40 <HLCD_vShowInt+0xa2>
 f28:	e1 e0       	ldi	r30, 0x01	; 1
 f2a:	f0 e0       	ldi	r31, 0x00	; 0
 f2c:	ec 0f       	add	r30, r28
 f2e:	fd 1f       	adc	r31, r29
 f30:	e1 0f       	add	r30, r17
 f32:	f1 1d       	adc	r31, r1
 f34:	17 fd       	sbrc	r17, 7
 f36:	fa 95       	dec	r31
 f38:	80 81       	ld	r24, Z
 f3a:	0e 94 e4 0c 	call	0x19c8	; 0x19c8 <HLCD_vsendData>
 f3e:	11 50       	subi	r17, 0x01	; 1
 f40:	11 23       	and	r17, r17
 f42:	94 f7       	brge	.-28     	; 0xf28 <HLCD_vShowInt+0x8a>
 f44:	03 c0       	rjmp	.+6      	; 0xf4c <HLCD_vShowInt+0xae>
 f46:	80 e3       	ldi	r24, 0x30	; 48
 f48:	0e 94 e4 0c 	call	0x19c8	; 0x19c8 <HLCD_vsendData>
 f4c:	2a 96       	adiw	r28, 0x0a	; 10
 f4e:	0f b6       	in	r0, 0x3f	; 63
 f50:	f8 94       	cli
 f52:	de bf       	out	0x3e, r29	; 62
 f54:	0f be       	out	0x3f, r0	; 63
 f56:	cd bf       	out	0x3d, r28	; 61
 f58:	df 91       	pop	r29
 f5a:	cf 91       	pop	r28
 f5c:	1f 91       	pop	r17
 f5e:	08 95       	ret

Disassembly of section .text.HLCD_vsendCommand:

00001a30 <HLCD_vsendCommand>:
    1a30:	9b b3       	in	r25, 0x1b	; 27
    1a32:	9f 70       	andi	r25, 0x0F	; 15
    1a34:	28 2f       	mov	r18, r24
    1a36:	20 7f       	andi	r18, 0xF0	; 240
    1a38:	92 2b       	or	r25, r18
    1a3a:	9b bb       	out	0x1b, r25	; 27
    1a3c:	98 b3       	in	r25, 0x18	; 24
    1a3e:	9d 7f       	andi	r25, 0xFD	; 253
    1a40:	98 bb       	out	0x18, r25	; 24
    1a42:	98 b3       	in	r25, 0x18	; 24
    1a44:	9b 7f       	andi	r25, 0xFB	; 251
    1a46:	98 bb       	out	0x18, r25	; 24
    1a48:	98 b3       	in	r25, 0x18	; 24
    1a4a:	98 60       	ori	r25, 0x08	; 8
    1a4c:	98 bb       	out	0x18, r25	; 24
    1a4e:	ef e9       	ldi	r30, 0x9F	; 159
    1a50:	ff e0       	ldi	r31, 0x0F	; 15
    1a52:	31 97       	sbiw	r30, 0x01	; 1
    1a54:	f1 f7       	brne	.-4      	; 0x1a52 <HLCD_vsendCommand+0x22>
    1a56:	00 c0       	rjmp	.+0      	; 0x1a58 <HLCD_vsendCommand+0x28>
    1a58:	00 00       	nop
    1a5a:	98 b3       	in	r25, 0x18	; 24
    1a5c:	97 7f       	andi	r25, 0xF7	; 247
    1a5e:	98 bb       	out	0x18, r25	; 24
    1a60:	2b b3       	in	r18, 0x1b	; 27
    1a62:	f0 e1       	ldi	r31, 0x10	; 16
    1a64:	8f 9f       	mul	r24, r31
    1a66:	c0 01       	movw	r24, r0
    1a68:	11 24       	eor	r1, r1
    1a6a:	92 2f       	mov	r25, r18
    1a6c:	9f 70       	andi	r25, 0x0F	; 15
    1a6e:	89 2b       	or	r24, r25
    1a70:	8b bb       	out	0x1b, r24	; 27
    1a72:	88 b3       	in	r24, 0x18	; 24
    1a74:	8d 7f       	andi	r24, 0xFD	; 253
    1a76:	88 bb       	out	0x18, r24	; 24
    1a78:	88 b3       	in	r24, 0x18	; 24
    1a7a:	8b 7f       	andi	r24, 0xFB	; 251
    1a7c:	88 bb       	out	0x18, r24	; 24
    1a7e:	88 b3       	in	r24, 0x18	; 24
    1a80:	88 60       	ori	r24, 0x08	; 8
    1a82:	88 bb       	out	0x18, r24	; 24
    1a84:	8f e9       	ldi	r24, 0x9F	; 159
    1a86:	9f e0       	ldi	r25, 0x0F	; 15
    1a88:	01 97       	sbiw	r24, 0x01	; 1
    1a8a:	f1 f7       	brne	.-4      	; 0x1a88 <HLCD_vsendCommand+0x58>
    1a8c:	00 c0       	rjmp	.+0      	; 0x1a8e <HLCD_vsendCommand+0x5e>
    1a8e:	00 00       	nop
    1a90:	88 b3       	in	r24, 0x18	; 24
    1a92:	87 7f       	andi	r24, 0xF7	; 247
    1a94:	88 bb       	out	0x18, r24	; 24
    1a96:	08 95       	ret

Disassembly of section .text.HLCD_vShowString:

00001e5c <HLCD_vShowString>:
	HLCD_vsendCommand(0x01);
	_delay_ms(2);

}

void HLCD_vShowString(u8 const * const  str){
    1e5c:	cf 92       	push	r12
    1e5e:	df 92       	push	r13
    1e60:	ef 92       	push	r14
    1e62:	cf 93       	push	r28
    1e64:	6b 01       	movw	r12, r22
    1e66:	e8 2e       	mov	r14, r24
	u8 i = 0;
    1e68:	c0 e0       	ldi	r28, 0x00	; 0
	while(str[i]!=0){
    1e6a:	09 c0       	rjmp	.+18     	; 0x1e7e <HLCD_vShowString+0x22>
		HLCD_vsendData(str[i]);
    1e6c:	0e 94 e4 0c 	call	0x19c8	; 0x19c8 <HLCD_vsendData>
    1e70:	8f e9       	ldi	r24, 0x9F	; 159
    1e72:	9f e0       	ldi	r25, 0x0F	; 15
    1e74:	01 97       	sbiw	r24, 0x01	; 1
    1e76:	f1 f7       	brne	.-4      	; 0x1e74 <HLCD_vShowString+0x18>
    1e78:	00 c0       	rjmp	.+0      	; 0x1e7a <HLCD_vShowString+0x1e>
    1e7a:	00 00       	nop
		_delay_ms(1);
		i++;
    1e7c:	cf 5f       	subi	r28, 0xFF	; 255

}

void HLCD_vShowString(u8 const * const  str){
	u8 i = 0;
	while(str[i]!=0){
    1e7e:	ae 2d       	mov	r26, r14
    1e80:	c6 01       	movw	r24, r12
    1e82:	8c 0f       	add	r24, r28
    1e84:	91 1d       	adc	r25, r1
    1e86:	a1 1d       	adc	r26, r1
    1e88:	fc 01       	movw	r30, r24
    1e8a:	84 91       	lpm	r24, Z
    1e8c:	a7 fd       	sbrc	r26, 7
    1e8e:	80 81       	ld	r24, Z
    1e90:	81 11       	cpse	r24, r1
    1e92:	ec cf       	rjmp	.-40     	; 0x1e6c <HLCD_vShowString+0x10>
		HLCD_vsendData(str[i]);
		_delay_ms(1);
		i++;
	}
	
}
    1e94:	cf 91       	pop	r28
    1e96:	ef 90       	pop	r14
    1e98:	df 90       	pop	r13
    1e9a:	cf 90       	pop	r12
    1e9c:	08 95       	ret

Disassembly of section .text.HLCD_vInit:

00001804 <HLCD_vInit>:
    1804:	8f e0       	ldi	r24, 0x0F	; 15
    1806:	87 bb       	out	0x17, r24	; 23
    1808:	80 ef       	ldi	r24, 0xF0	; 240
    180a:	8a bb       	out	0x1a, r24	; 26
    180c:	2f ef       	ldi	r18, 0xFF	; 255
    180e:	83 ef       	ldi	r24, 0xF3	; 243
    1810:	91 e0       	ldi	r25, 0x01	; 1
    1812:	21 50       	subi	r18, 0x01	; 1
    1814:	80 40       	sbci	r24, 0x00	; 0
    1816:	90 40       	sbci	r25, 0x00	; 0
    1818:	e1 f7       	brne	.-8      	; 0x1812 <HLCD_vInit+0xe>
    181a:	00 c0       	rjmp	.+0      	; 0x181c <HLCD_vInit+0x18>
    181c:	00 00       	nop
    181e:	88 e2       	ldi	r24, 0x28	; 40
    1820:	0e 94 18 0d 	call	0x1a30	; 0x1a30 <HLCD_vsendCommand>
    1824:	25 ed       	ldi	r18, 0xD5	; 213
    1826:	2a 95       	dec	r18
    1828:	f1 f7       	brne	.-4      	; 0x1826 <HLCD_vInit+0x22>
    182a:	00 00       	nop
    182c:	82 e0       	ldi	r24, 0x02	; 2
    182e:	0e 94 18 0d 	call	0x1a30	; 0x1a30 <HLCD_vsendCommand>
    1832:	8f e3       	ldi	r24, 0x3F	; 63
    1834:	9f e1       	ldi	r25, 0x1F	; 31
    1836:	01 97       	sbiw	r24, 0x01	; 1
    1838:	f1 f7       	brne	.-4      	; 0x1836 <HLCD_vInit+0x32>
    183a:	00 c0       	rjmp	.+0      	; 0x183c <HLCD_vInit+0x38>
    183c:	00 00       	nop
    183e:	86 e0       	ldi	r24, 0x06	; 6
    1840:	0e 94 18 0d 	call	0x1a30	; 0x1a30 <HLCD_vsendCommand>
    1844:	95 ed       	ldi	r25, 0xD5	; 213
    1846:	9a 95       	dec	r25
    1848:	f1 f7       	brne	.-4      	; 0x1846 <HLCD_vInit+0x42>
    184a:	00 00       	nop
    184c:	8f e0       	ldi	r24, 0x0F	; 15
    184e:	0e 94 18 0d 	call	0x1a30	; 0x1a30 <HLCD_vsendCommand>
    1852:	84 e1       	ldi	r24, 0x14	; 20
    1854:	0e 94 18 0d 	call	0x1a30	; 0x1a30 <HLCD_vsendCommand>
    1858:	25 ed       	ldi	r18, 0xD5	; 213
    185a:	2a 95       	dec	r18
    185c:	f1 f7       	brne	.-4      	; 0x185a <HLCD_vInit+0x56>
    185e:	00 00       	nop
    1860:	81 e0       	ldi	r24, 0x01	; 1
    1862:	0e 94 18 0d 	call	0x1a30	; 0x1a30 <HLCD_vsendCommand>
    1866:	8f ef       	ldi	r24, 0xFF	; 255
    1868:	93 ec       	ldi	r25, 0xC3	; 195
    186a:	29 e0       	ldi	r18, 0x09	; 9
    186c:	81 50       	subi	r24, 0x01	; 1
    186e:	90 40       	sbci	r25, 0x00	; 0
    1870:	20 40       	sbci	r18, 0x00	; 0
    1872:	e1 f7       	brne	.-8      	; 0x186c <HLCD_vInit+0x68>
    1874:	00 c0       	rjmp	.+0      	; 0x1876 <HLCD_vInit+0x72>
    1876:	00 00       	nop
    1878:	08 95       	ret

Disassembly of section .text.vListInitialise:

00002138 <vListInitialise>:
/*-----------------------------------------------------------
* PUBLIC LIST API documented in list.h
*----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    2138:	fc 01       	movw	r30, r24
    /* The list structure contains a list item which is used to mark the
     * end of the list.  To initialise the list the list end is inserted
     * as the only list entry. */
    pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    213a:	03 96       	adiw	r24, 0x03	; 3
    213c:	92 83       	std	Z+2, r25	; 0x02
    213e:	81 83       	std	Z+1, r24	; 0x01

    listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( &( pxList->xListEnd ) );

    /* The list end value is the highest possible value in the list to
     * ensure it remains at the end of the list. */
    pxList->xListEnd.xItemValue = portMAX_DELAY;
    2140:	2f ef       	ldi	r18, 0xFF	; 255
    2142:	3f ef       	ldi	r19, 0xFF	; 255
    2144:	34 83       	std	Z+4, r19	; 0x04
    2146:	23 83       	std	Z+3, r18	; 0x03

    /* The list end next and previous pointers point to itself so we know
     * when the list is empty. */
    pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );     /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    2148:	96 83       	std	Z+6, r25	; 0x06
    214a:	85 83       	std	Z+5, r24	; 0x05
    pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    214c:	90 87       	std	Z+8, r25	; 0x08
    214e:	87 83       	std	Z+7, r24	; 0x07
        pxList->xListEnd.pxContainer = NULL;
        listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( &( pxList->xListEnd ) );
    }
    #endif

    pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    2150:	10 82       	st	Z, r1
    2152:	08 95       	ret

Disassembly of section .text.vListInitialiseItem:

0000221a <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    /* Make sure the list item is not recorded as being on a list. */
    pxItem->pxContainer = NULL;
    221a:	fc 01       	movw	r30, r24
    221c:	11 86       	std	Z+9, r1	; 0x09
    221e:	10 86       	std	Z+8, r1	; 0x08
    2220:	08 95       	ret

Disassembly of section .text.vListInsert:

00001afe <vListInsert>:
}
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList,
                  ListItem_t * const pxNewListItem )
{
    1afe:	cf 93       	push	r28
    1b00:	df 93       	push	r29
    1b02:	eb 01       	movw	r28, r22
    ListItem_t * pxIterator;
    const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    1b04:	48 81       	ld	r20, Y
    1b06:	59 81       	ldd	r21, Y+1	; 0x01
     * new list item should be placed after it.  This ensures that TCBs which are
     * stored in ready lists (all of which have the same xItemValue value) get a
     * share of the CPU.  However, if the xItemValue is the same as the back marker
     * the iteration loop below will not end.  Therefore the value is checked
     * first, and the algorithm slightly modified if necessary. */
    if( xValueOfInsertion == portMAX_DELAY )
    1b08:	4f 3f       	cpi	r20, 0xFF	; 255
    1b0a:	2f ef       	ldi	r18, 0xFF	; 255
    1b0c:	52 07       	cpc	r21, r18
    1b0e:	21 f4       	brne	.+8      	; 0x1b18 <vListInsert+0x1a>
    {
        pxIterator = pxList->xListEnd.pxPrevious;
    1b10:	fc 01       	movw	r30, r24
    1b12:	a7 81       	ldd	r26, Z+7	; 0x07
    1b14:	b0 85       	ldd	r27, Z+8	; 0x08
    1b16:	0d c0       	rjmp	.+26     	; 0x1b32 <vListInsert+0x34>
        *   5) If the FreeRTOS port supports interrupt nesting then ensure that
        *      the priority of the tick interrupt is at or below
        *      configMAX_SYSCALL_INTERRUPT_PRIORITY.
        **********************************************************************/

        for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
    1b18:	dc 01       	movw	r26, r24
    1b1a:	13 96       	adiw	r26, 0x03	; 3
    1b1c:	01 c0       	rjmp	.+2      	; 0x1b20 <vListInsert+0x22>
    1b1e:	df 01       	movw	r26, r30
    1b20:	12 96       	adiw	r26, 0x02	; 2
    1b22:	ed 91       	ld	r30, X+
    1b24:	fc 91       	ld	r31, X
    1b26:	13 97       	sbiw	r26, 0x03	; 3
    1b28:	20 81       	ld	r18, Z
    1b2a:	31 81       	ldd	r19, Z+1	; 0x01
    1b2c:	42 17       	cp	r20, r18
    1b2e:	53 07       	cpc	r21, r19
    1b30:	b0 f7       	brcc	.-20     	; 0x1b1e <vListInsert+0x20>
            /* There is nothing to do here, just iterating to the wanted
             * insertion position. */
        }
    }

    pxNewListItem->pxNext = pxIterator->pxNext;
    1b32:	12 96       	adiw	r26, 0x02	; 2
    1b34:	ed 91       	ld	r30, X+
    1b36:	fc 91       	ld	r31, X
    1b38:	13 97       	sbiw	r26, 0x03	; 3
    1b3a:	fb 83       	std	Y+3, r31	; 0x03
    1b3c:	ea 83       	std	Y+2, r30	; 0x02
    pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    1b3e:	d5 83       	std	Z+5, r29	; 0x05
    1b40:	c4 83       	std	Z+4, r28	; 0x04
    pxNewListItem->pxPrevious = pxIterator;
    1b42:	bd 83       	std	Y+5, r27	; 0x05
    1b44:	ac 83       	std	Y+4, r26	; 0x04
    pxIterator->pxNext = pxNewListItem;
    1b46:	13 96       	adiw	r26, 0x03	; 3
    1b48:	dc 93       	st	X, r29
    1b4a:	ce 93       	st	-X, r28
    1b4c:	12 97       	sbiw	r26, 0x02	; 2

    /* Remember which list the item is in.  This allows fast removal of the
     * item later. */
    pxNewListItem->pxContainer = pxList;
    1b4e:	99 87       	std	Y+9, r25	; 0x09
    1b50:	88 87       	std	Y+8, r24	; 0x08

    ( pxList->uxNumberOfItems )++;
    1b52:	fc 01       	movw	r30, r24
    1b54:	20 81       	ld	r18, Z
    1b56:	2f 5f       	subi	r18, 0xFF	; 255
    1b58:	20 83       	st	Z, r18
}
    1b5a:	df 91       	pop	r29
    1b5c:	cf 91       	pop	r28
    1b5e:	08 95       	ret

Disassembly of section .text.uxListRemove:

00001d7a <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    1d7a:	cf 93       	push	r28
    1d7c:	df 93       	push	r29
    1d7e:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
 * item. */
    List_t * const pxList = pxItemToRemove->pxContainer;
    1d80:	a0 85       	ldd	r26, Z+8	; 0x08
    1d82:	b1 85       	ldd	r27, Z+9	; 0x09

    pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    1d84:	c2 81       	ldd	r28, Z+2	; 0x02
    1d86:	d3 81       	ldd	r29, Z+3	; 0x03
    1d88:	84 81       	ldd	r24, Z+4	; 0x04
    1d8a:	95 81       	ldd	r25, Z+5	; 0x05
    1d8c:	9d 83       	std	Y+5, r25	; 0x05
    1d8e:	8c 83       	std	Y+4, r24	; 0x04
    pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    1d90:	c4 81       	ldd	r28, Z+4	; 0x04
    1d92:	d5 81       	ldd	r29, Z+5	; 0x05
    1d94:	82 81       	ldd	r24, Z+2	; 0x02
    1d96:	93 81       	ldd	r25, Z+3	; 0x03
    1d98:	9b 83       	std	Y+3, r25	; 0x03
    1d9a:	8a 83       	std	Y+2, r24	; 0x02

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    /* Make sure the index is left pointing to a valid item. */
    if( pxList->pxIndex == pxItemToRemove )
    1d9c:	11 96       	adiw	r26, 0x01	; 1
    1d9e:	8d 91       	ld	r24, X+
    1da0:	9c 91       	ld	r25, X
    1da2:	12 97       	sbiw	r26, 0x02	; 2
    1da4:	e8 17       	cp	r30, r24
    1da6:	f9 07       	cpc	r31, r25
    1da8:	31 f4       	brne	.+12     	; 0x1db6 <uxListRemove+0x3c>
    {
        pxList->pxIndex = pxItemToRemove->pxPrevious;
    1daa:	84 81       	ldd	r24, Z+4	; 0x04
    1dac:	95 81       	ldd	r25, Z+5	; 0x05
    1dae:	12 96       	adiw	r26, 0x02	; 2
    1db0:	9c 93       	st	X, r25
    1db2:	8e 93       	st	-X, r24
    1db4:	11 97       	sbiw	r26, 0x01	; 1
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxItemToRemove->pxContainer = NULL;
    1db6:	11 86       	std	Z+9, r1	; 0x09
    1db8:	10 86       	std	Z+8, r1	; 0x08
    ( pxList->uxNumberOfItems )--;
    1dba:	8c 91       	ld	r24, X
    1dbc:	81 50       	subi	r24, 0x01	; 1
    1dbe:	8c 93       	st	X, r24

    return pxList->uxNumberOfItems;
    1dc0:	8c 91       	ld	r24, X
}
    1dc2:	df 91       	pop	r29
    1dc4:	cf 91       	pop	r28
    1dc6:	08 95       	ret

Disassembly of section .text.OneshotTask:

000021ec <OneshotTask>:
BaseType_t    oneShot_started,autoRelaod_started ;

size_t timerHandleSize = sizeof(TimerHandle_t);

void OneshotTask(TimerHandle_t t){
	HLCD_vShowString("One");
    21ec:	60 ec       	ldi	r22, 0xC0	; 192
    21ee:	70 e0       	ldi	r23, 0x00	; 0
    21f0:	80 e0       	ldi	r24, 0x00	; 0
    21f2:	0e 94 2e 0f 	call	0x1e5c	; 0x1e5c <HLCD_vShowString>
    21f6:	08 95       	ret

Disassembly of section .text.AutoReloadTask:

00002210 <AutoReloadTask>:
}


void AutoReloadTask(TimerHandle_t t){
// 	HLCD_vShowString("Auto");
HLCD_vShowInt(sizeof(timerHandleSize));
    2210:	82 e0       	ldi	r24, 0x02	; 2
    2212:	90 e0       	ldi	r25, 0x00	; 0
    2214:	0e 94 4f 07 	call	0xe9e	; 0xe9e <HLCD_vShowInt>
    2218:	08 95       	ret

Disassembly of section .text.main:

000012f0 <main>:
}

int main(void)
{
    12f0:	ef 92       	push	r14
    12f2:	ff 92       	push	r15
    12f4:	0f 93       	push	r16
    12f6:	1f 93       	push	r17
	
	HLCD_vInit();
    12f8:	0e 94 02 0c 	call	0x1804	; 0x1804 <HLCD_vInit>
	oneShot = xTimerCreate("OneShot",
    12fc:	0f 2e       	mov	r0, r31
    12fe:	f6 ef       	ldi	r31, 0xF6	; 246
    1300:	ef 2e       	mov	r14, r31
    1302:	f0 e1       	ldi	r31, 0x10	; 16
    1304:	ff 2e       	mov	r15, r31
    1306:	f0 2d       	mov	r31, r0
    1308:	00 e0       	ldi	r16, 0x00	; 0
    130a:	10 e0       	ldi	r17, 0x00	; 0
    130c:	20 e0       	ldi	r18, 0x00	; 0
    130e:	48 ee       	ldi	r20, 0xE8	; 232
    1310:	53 e0       	ldi	r21, 0x03	; 3
    1312:	64 ec       	ldi	r22, 0xC4	; 196
    1314:	70 e0       	ldi	r23, 0x00	; 0
    1316:	80 e0       	ldi	r24, 0x00	; 0
    1318:	0e 94 b0 0d 	call	0x1b60	; 0x1b60 <xTimerCreate>
    131c:	90 93 63 00 	sts	0x0063, r25	; 0x800063 <oneShot+0x1>
    1320:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <oneShot>
	1000/portTICK_PERIOD_MS,
	pdFALSE,
	NULL,
	&OneshotTask);
	
	autoReload = xTimerCreate("AutoReload",
    1324:	0f 2e       	mov	r0, r31
    1326:	f8 e0       	ldi	r31, 0x08	; 8
    1328:	ef 2e       	mov	r14, r31
    132a:	f1 e1       	ldi	r31, 0x11	; 17
    132c:	ff 2e       	mov	r15, r31
    132e:	f0 2d       	mov	r31, r0
    1330:	21 e0       	ldi	r18, 0x01	; 1
    1332:	44 ef       	ldi	r20, 0xF4	; 244
    1334:	51 e0       	ldi	r21, 0x01	; 1
    1336:	6c ec       	ldi	r22, 0xCC	; 204
    1338:	70 e0       	ldi	r23, 0x00	; 0
    133a:	80 e0       	ldi	r24, 0x00	; 0
    133c:	0e 94 b0 0d 	call	0x1b60	; 0x1b60 <xTimerCreate>
    1340:	90 93 65 00 	sts	0x0065, r25	; 0x800065 <autoReload+0x1>
    1344:	80 93 64 00 	sts	0x0064, r24	; 0x800064 <autoReload>
	500/portTICK_PERIOD_MS,
	pdTRUE,
	NULL,
	&AutoReloadTask);
	
	oneShot_started = xTimerStart(oneShot,0);
    1348:	0e 94 db 10 	call	0x21b6	; 0x21b6 <xTaskGetTickCount>
    134c:	20 e0       	ldi	r18, 0x00	; 0
    134e:	30 e0       	ldi	r19, 0x00	; 0
    1350:	ac 01       	movw	r20, r24
    1352:	61 e0       	ldi	r22, 0x01	; 1
    1354:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <oneShot>
    1358:	90 91 63 00 	lds	r25, 0x0063	; 0x800063 <oneShot+0x1>
    135c:	0e 94 c9 09 	call	0x1392	; 0x1392 <xTimerGenericCommand>
    1360:	80 93 61 00 	sts	0x0061, r24	; 0x800061 <oneShot_started>
	autoRelaod_started = xTimerStart(autoReload,0);
    1364:	0e 94 db 10 	call	0x21b6	; 0x21b6 <xTaskGetTickCount>
    1368:	20 e0       	ldi	r18, 0x00	; 0
    136a:	30 e0       	ldi	r19, 0x00	; 0
    136c:	ac 01       	movw	r20, r24
    136e:	61 e0       	ldi	r22, 0x01	; 1
    1370:	80 91 64 00 	lds	r24, 0x0064	; 0x800064 <autoReload>
    1374:	90 91 65 00 	lds	r25, 0x0065	; 0x800065 <autoReload+0x1>
    1378:	0e 94 c9 09 	call	0x1392	; 0x1392 <xTimerGenericCommand>
    137c:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>

	vTaskStartScheduler();
    1380:	0e 94 4c 0d 	call	0x1a98	; 0x1a98 <vTaskStartScheduler>
}
    1384:	80 e0       	ldi	r24, 0x00	; 0
    1386:	90 e0       	ldi	r25, 0x00	; 0
    1388:	1f 91       	pop	r17
    138a:	0f 91       	pop	r16
    138c:	ff 90       	pop	r15
    138e:	ef 90       	pop	r14
    1390:	08 95       	ret

Disassembly of section .text.prvSetupTimerInterrupt:

000021ca <prvSetupTimerInterrupt>:
	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
	ulCompareMatch >>= 8;
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
	OCR1AH = ucHighByte;
    21ca:	1b bc       	out	0x2b, r1	; 43
	OCR1AL = ucLowByte;
    21cc:	89 ef       	ldi	r24, 0xF9	; 249
    21ce:	8a bd       	out	0x2a, r24	; 42

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	TCCR1B = ucLowByte;
    21d0:	8b e0       	ldi	r24, 0x0B	; 11
    21d2:	8e bd       	out	0x2e, r24	; 46

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    21d4:	89 b7       	in	r24, 0x39	; 57
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    21d6:	80 61       	ori	r24, 0x10	; 16
	TIMSK = ucLowByte;
    21d8:	89 bf       	out	0x39, r24	; 57
    21da:	08 95       	ret

Disassembly of section .text.pxPortInitialiseStack:

00000dc6 <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
 dc6:	31 e1       	ldi	r19, 0x11	; 17
 dc8:	fc 01       	movw	r30, r24
 dca:	30 83       	st	Z, r19
 dcc:	31 97       	sbiw	r30, 0x01	; 1
 dce:	22 e2       	ldi	r18, 0x22	; 34
 dd0:	20 83       	st	Z, r18
 dd2:	31 97       	sbiw	r30, 0x01	; 1
 dd4:	a3 e3       	ldi	r26, 0x33	; 51
 dd6:	a0 83       	st	Z, r26
 dd8:	31 97       	sbiw	r30, 0x01	; 1
 dda:	60 83       	st	Z, r22
 ddc:	31 97       	sbiw	r30, 0x01	; 1
 dde:	70 83       	st	Z, r23
 de0:	31 97       	sbiw	r30, 0x01	; 1
 de2:	10 82       	st	Z, r1
 de4:	31 97       	sbiw	r30, 0x01	; 1
 de6:	60 e8       	ldi	r22, 0x80	; 128
 de8:	60 83       	st	Z, r22
 dea:	31 97       	sbiw	r30, 0x01	; 1
 dec:	10 82       	st	Z, r1
 dee:	31 97       	sbiw	r30, 0x01	; 1
 df0:	62 e0       	ldi	r22, 0x02	; 2
 df2:	60 83       	st	Z, r22
 df4:	31 97       	sbiw	r30, 0x01	; 1
 df6:	63 e0       	ldi	r22, 0x03	; 3
 df8:	60 83       	st	Z, r22
 dfa:	31 97       	sbiw	r30, 0x01	; 1
 dfc:	64 e0       	ldi	r22, 0x04	; 4
 dfe:	60 83       	st	Z, r22
 e00:	31 97       	sbiw	r30, 0x01	; 1
 e02:	65 e0       	ldi	r22, 0x05	; 5
 e04:	60 83       	st	Z, r22
 e06:	31 97       	sbiw	r30, 0x01	; 1
 e08:	66 e0       	ldi	r22, 0x06	; 6
 e0a:	60 83       	st	Z, r22
 e0c:	31 97       	sbiw	r30, 0x01	; 1
 e0e:	67 e0       	ldi	r22, 0x07	; 7
 e10:	60 83       	st	Z, r22
 e12:	31 97       	sbiw	r30, 0x01	; 1
 e14:	68 e0       	ldi	r22, 0x08	; 8
 e16:	60 83       	st	Z, r22
 e18:	31 97       	sbiw	r30, 0x01	; 1
 e1a:	69 e0       	ldi	r22, 0x09	; 9
 e1c:	60 83       	st	Z, r22
 e1e:	31 97       	sbiw	r30, 0x01	; 1
 e20:	60 e1       	ldi	r22, 0x10	; 16
 e22:	60 83       	st	Z, r22
 e24:	31 97       	sbiw	r30, 0x01	; 1
 e26:	30 83       	st	Z, r19
 e28:	31 97       	sbiw	r30, 0x01	; 1
 e2a:	32 e1       	ldi	r19, 0x12	; 18
 e2c:	30 83       	st	Z, r19
 e2e:	31 97       	sbiw	r30, 0x01	; 1
 e30:	33 e1       	ldi	r19, 0x13	; 19
 e32:	30 83       	st	Z, r19
 e34:	31 97       	sbiw	r30, 0x01	; 1
 e36:	34 e1       	ldi	r19, 0x14	; 20
 e38:	30 83       	st	Z, r19
 e3a:	31 97       	sbiw	r30, 0x01	; 1
 e3c:	35 e1       	ldi	r19, 0x15	; 21
 e3e:	30 83       	st	Z, r19
 e40:	31 97       	sbiw	r30, 0x01	; 1
 e42:	36 e1       	ldi	r19, 0x16	; 22
 e44:	30 83       	st	Z, r19
 e46:	31 97       	sbiw	r30, 0x01	; 1
 e48:	37 e1       	ldi	r19, 0x17	; 23
 e4a:	30 83       	st	Z, r19
 e4c:	31 97       	sbiw	r30, 0x01	; 1
 e4e:	38 e1       	ldi	r19, 0x18	; 24
 e50:	30 83       	st	Z, r19
 e52:	31 97       	sbiw	r30, 0x01	; 1
 e54:	39 e1       	ldi	r19, 0x19	; 25
 e56:	30 83       	st	Z, r19
 e58:	31 97       	sbiw	r30, 0x01	; 1
 e5a:	30 e2       	ldi	r19, 0x20	; 32
 e5c:	30 83       	st	Z, r19
 e5e:	31 97       	sbiw	r30, 0x01	; 1
 e60:	31 e2       	ldi	r19, 0x21	; 33
 e62:	30 83       	st	Z, r19
 e64:	31 97       	sbiw	r30, 0x01	; 1
 e66:	20 83       	st	Z, r18
 e68:	31 97       	sbiw	r30, 0x01	; 1
 e6a:	23 e2       	ldi	r18, 0x23	; 35
 e6c:	20 83       	st	Z, r18
 e6e:	31 97       	sbiw	r30, 0x01	; 1
 e70:	40 83       	st	Z, r20
 e72:	31 97       	sbiw	r30, 0x01	; 1
 e74:	50 83       	st	Z, r21
 e76:	31 97       	sbiw	r30, 0x01	; 1
 e78:	26 e2       	ldi	r18, 0x26	; 38
 e7a:	20 83       	st	Z, r18
 e7c:	31 97       	sbiw	r30, 0x01	; 1
 e7e:	27 e2       	ldi	r18, 0x27	; 39
 e80:	20 83       	st	Z, r18
 e82:	31 97       	sbiw	r30, 0x01	; 1
 e84:	28 e2       	ldi	r18, 0x28	; 40
 e86:	20 83       	st	Z, r18
 e88:	31 97       	sbiw	r30, 0x01	; 1
 e8a:	29 e2       	ldi	r18, 0x29	; 41
 e8c:	20 83       	st	Z, r18
 e8e:	31 97       	sbiw	r30, 0x01	; 1
 e90:	20 e3       	ldi	r18, 0x30	; 48
 e92:	20 83       	st	Z, r18
 e94:	31 97       	sbiw	r30, 0x01	; 1
 e96:	21 e3       	ldi	r18, 0x31	; 49
 e98:	20 83       	st	Z, r18
 e9a:	86 97       	sbiw	r24, 0x26	; 38
 e9c:	08 95       	ret

Disassembly of section .text.xPortStartScheduler:

00001bc2 <xPortStartScheduler>:
/*-----------------------------------------------------------*/

BaseType_t xPortStartScheduler( void )
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
    1bc2:	0e 94 e5 10 	call	0x21ca	; 0x21ca <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    1bc6:	a0 91 b5 06 	lds	r26, 0x06B5	; 0x8006b5 <pxCurrentTCB>
    1bca:	b0 91 b6 06 	lds	r27, 0x06B6	; 0x8006b6 <pxCurrentTCB+0x1>
    1bce:	cd 91       	ld	r28, X+
    1bd0:	cd bf       	out	0x3d, r28	; 61
    1bd2:	dd 91       	ld	r29, X+
    1bd4:	de bf       	out	0x3e, r29	; 62
    1bd6:	ff 91       	pop	r31
    1bd8:	ef 91       	pop	r30
    1bda:	df 91       	pop	r29
    1bdc:	cf 91       	pop	r28
    1bde:	bf 91       	pop	r27
    1be0:	af 91       	pop	r26
    1be2:	9f 91       	pop	r25
    1be4:	8f 91       	pop	r24
    1be6:	7f 91       	pop	r23
    1be8:	6f 91       	pop	r22
    1bea:	5f 91       	pop	r21
    1bec:	4f 91       	pop	r20
    1bee:	3f 91       	pop	r19
    1bf0:	2f 91       	pop	r18
    1bf2:	1f 91       	pop	r17
    1bf4:	0f 91       	pop	r16
    1bf6:	ff 90       	pop	r15
    1bf8:	ef 90       	pop	r14
    1bfa:	df 90       	pop	r13
    1bfc:	cf 90       	pop	r12
    1bfe:	bf 90       	pop	r11
    1c00:	af 90       	pop	r10
    1c02:	9f 90       	pop	r9
    1c04:	8f 90       	pop	r8
    1c06:	7f 90       	pop	r7
    1c08:	6f 90       	pop	r6
    1c0a:	5f 90       	pop	r5
    1c0c:	4f 90       	pop	r4
    1c0e:	3f 90       	pop	r3
    1c10:	2f 90       	pop	r2
    1c12:	1f 90       	pop	r1
    1c14:	0f 90       	pop	r0
    1c16:	0f be       	out	0x3f, r0	; 63
    1c18:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    1c1a:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
    1c1c:	81 e0       	ldi	r24, 0x01	; 1
    1c1e:	08 95       	ret

Disassembly of section .text.vPortYield:

00001196 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    1196:	0f 92       	push	r0
    1198:	0f b6       	in	r0, 0x3f	; 63
    119a:	f8 94       	cli
    119c:	0f 92       	push	r0
    119e:	1f 92       	push	r1
    11a0:	11 24       	eor	r1, r1
    11a2:	2f 92       	push	r2
    11a4:	3f 92       	push	r3
    11a6:	4f 92       	push	r4
    11a8:	5f 92       	push	r5
    11aa:	6f 92       	push	r6
    11ac:	7f 92       	push	r7
    11ae:	8f 92       	push	r8
    11b0:	9f 92       	push	r9
    11b2:	af 92       	push	r10
    11b4:	bf 92       	push	r11
    11b6:	cf 92       	push	r12
    11b8:	df 92       	push	r13
    11ba:	ef 92       	push	r14
    11bc:	ff 92       	push	r15
    11be:	0f 93       	push	r16
    11c0:	1f 93       	push	r17
    11c2:	2f 93       	push	r18
    11c4:	3f 93       	push	r19
    11c6:	4f 93       	push	r20
    11c8:	5f 93       	push	r21
    11ca:	6f 93       	push	r22
    11cc:	7f 93       	push	r23
    11ce:	8f 93       	push	r24
    11d0:	9f 93       	push	r25
    11d2:	af 93       	push	r26
    11d4:	bf 93       	push	r27
    11d6:	cf 93       	push	r28
    11d8:	df 93       	push	r29
    11da:	ef 93       	push	r30
    11dc:	ff 93       	push	r31
    11de:	a0 91 b5 06 	lds	r26, 0x06B5	; 0x8006b5 <pxCurrentTCB>
    11e2:	b0 91 b6 06 	lds	r27, 0x06B6	; 0x8006b6 <pxCurrentTCB+0x1>
    11e6:	0d b6       	in	r0, 0x3d	; 61
    11e8:	0d 92       	st	X+, r0
    11ea:	0e b6       	in	r0, 0x3e	; 62
    11ec:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    11ee:	0e 94 24 09 	call	0x1248	; 0x1248 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    11f2:	a0 91 b5 06 	lds	r26, 0x06B5	; 0x8006b5 <pxCurrentTCB>
    11f6:	b0 91 b6 06 	lds	r27, 0x06B6	; 0x8006b6 <pxCurrentTCB+0x1>
    11fa:	cd 91       	ld	r28, X+
    11fc:	cd bf       	out	0x3d, r28	; 61
    11fe:	dd 91       	ld	r29, X+
    1200:	de bf       	out	0x3e, r29	; 62
    1202:	ff 91       	pop	r31
    1204:	ef 91       	pop	r30
    1206:	df 91       	pop	r29
    1208:	cf 91       	pop	r28
    120a:	bf 91       	pop	r27
    120c:	af 91       	pop	r26
    120e:	9f 91       	pop	r25
    1210:	8f 91       	pop	r24
    1212:	7f 91       	pop	r23
    1214:	6f 91       	pop	r22
    1216:	5f 91       	pop	r21
    1218:	4f 91       	pop	r20
    121a:	3f 91       	pop	r19
    121c:	2f 91       	pop	r18
    121e:	1f 91       	pop	r17
    1220:	0f 91       	pop	r16
    1222:	ff 90       	pop	r15
    1224:	ef 90       	pop	r14
    1226:	df 90       	pop	r13
    1228:	cf 90       	pop	r12
    122a:	bf 90       	pop	r11
    122c:	af 90       	pop	r10
    122e:	9f 90       	pop	r9
    1230:	8f 90       	pop	r8
    1232:	7f 90       	pop	r7
    1234:	6f 90       	pop	r6
    1236:	5f 90       	pop	r5
    1238:	4f 90       	pop	r4
    123a:	3f 90       	pop	r3
    123c:	2f 90       	pop	r2
    123e:	1f 90       	pop	r1
    1240:	0f 90       	pop	r0
    1242:	0f be       	out	0x3f, r0	; 63
    1244:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1246:	08 95       	ret

Disassembly of section .text.vPortYieldFromTick:

000010de <vPortYieldFromTick>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    10de:	0f 92       	push	r0
    10e0:	0f b6       	in	r0, 0x3f	; 63
    10e2:	f8 94       	cli
    10e4:	0f 92       	push	r0
    10e6:	1f 92       	push	r1
    10e8:	11 24       	eor	r1, r1
    10ea:	2f 92       	push	r2
    10ec:	3f 92       	push	r3
    10ee:	4f 92       	push	r4
    10f0:	5f 92       	push	r5
    10f2:	6f 92       	push	r6
    10f4:	7f 92       	push	r7
    10f6:	8f 92       	push	r8
    10f8:	9f 92       	push	r9
    10fa:	af 92       	push	r10
    10fc:	bf 92       	push	r11
    10fe:	cf 92       	push	r12
    1100:	df 92       	push	r13
    1102:	ef 92       	push	r14
    1104:	ff 92       	push	r15
    1106:	0f 93       	push	r16
    1108:	1f 93       	push	r17
    110a:	2f 93       	push	r18
    110c:	3f 93       	push	r19
    110e:	4f 93       	push	r20
    1110:	5f 93       	push	r21
    1112:	6f 93       	push	r22
    1114:	7f 93       	push	r23
    1116:	8f 93       	push	r24
    1118:	9f 93       	push	r25
    111a:	af 93       	push	r26
    111c:	bf 93       	push	r27
    111e:	cf 93       	push	r28
    1120:	df 93       	push	r29
    1122:	ef 93       	push	r30
    1124:	ff 93       	push	r31
    1126:	a0 91 b5 06 	lds	r26, 0x06B5	; 0x8006b5 <pxCurrentTCB>
    112a:	b0 91 b6 06 	lds	r27, 0x06B6	; 0x8006b6 <pxCurrentTCB+0x1>
    112e:	0d b6       	in	r0, 0x3d	; 61
    1130:	0d 92       	st	X+, r0
    1132:	0e b6       	in	r0, 0x3e	; 62
    1134:	0d 92       	st	X+, r0
    1136:	0e 94 73 00 	call	0xe6	; 0xe6 <xTaskIncrementTick>
    113a:	81 11       	cpse	r24, r1
    113c:	0e 94 24 09 	call	0x1248	; 0x1248 <vTaskSwitchContext>
    1140:	a0 91 b5 06 	lds	r26, 0x06B5	; 0x8006b5 <pxCurrentTCB>
    1144:	b0 91 b6 06 	lds	r27, 0x06B6	; 0x8006b6 <pxCurrentTCB+0x1>
    1148:	cd 91       	ld	r28, X+
    114a:	cd bf       	out	0x3d, r28	; 61
    114c:	dd 91       	ld	r29, X+
    114e:	de bf       	out	0x3e, r29	; 62
    1150:	ff 91       	pop	r31
    1152:	ef 91       	pop	r30
    1154:	df 91       	pop	r29
    1156:	cf 91       	pop	r28
    1158:	bf 91       	pop	r27
    115a:	af 91       	pop	r26
    115c:	9f 91       	pop	r25
    115e:	8f 91       	pop	r24
    1160:	7f 91       	pop	r23
    1162:	6f 91       	pop	r22
    1164:	5f 91       	pop	r21
    1166:	4f 91       	pop	r20
    1168:	3f 91       	pop	r19
    116a:	2f 91       	pop	r18
    116c:	1f 91       	pop	r17
    116e:	0f 91       	pop	r16
    1170:	ff 90       	pop	r15
    1172:	ef 90       	pop	r14
    1174:	df 90       	pop	r13
    1176:	cf 90       	pop	r12
    1178:	bf 90       	pop	r11
    117a:	af 90       	pop	r10
    117c:	9f 90       	pop	r9
    117e:	8f 90       	pop	r8
    1180:	7f 90       	pop	r7
    1182:	6f 90       	pop	r6
    1184:	5f 90       	pop	r5
    1186:	4f 90       	pop	r4
    1188:	3f 90       	pop	r3
    118a:	2f 90       	pop	r2
    118c:	1f 90       	pop	r1
    118e:	0f 90       	pop	r0
    1190:	0f be       	out	0x3f, r0	; 63
    1192:	0f 90       	pop	r0
    1194:	08 95       	ret

Disassembly of section .text.__vector_7:

0000222a <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
    222a:	0e 94 6f 08 	call	0x10de	; 0x10de <vPortYieldFromTick>
		asm volatile ( "reti" );
    222e:	18 95       	reti

Disassembly of section .text.prvIsQueueEmpty:

000020b2 <prvIsQueueEmpty>:

static BaseType_t prvIsQueueEmpty( const Queue_t * pxQueue )
{
    BaseType_t xReturn;

    taskENTER_CRITICAL();
    20b2:	0f b6       	in	r0, 0x3f	; 63
    20b4:	f8 94       	cli
    20b6:	0f 92       	push	r0
    {
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    20b8:	a8 2f       	mov	r26, r24
    20ba:	cb 01       	movw	r24, r22
    20bc:	4a 96       	adiw	r24, 0x1a	; 26
    20be:	a1 1d       	adc	r26, r1
    20c0:	fc 01       	movw	r30, r24
    20c2:	84 91       	lpm	r24, Z
    20c4:	a7 fd       	sbrc	r26, 7
    20c6:	80 81       	ld	r24, Z
    20c8:	81 11       	cpse	r24, r1
    20ca:	02 c0       	rjmp	.+4      	; 0x20d0 <prvIsQueueEmpty+0x1e>
        {
            xReturn = pdTRUE;
    20cc:	81 e0       	ldi	r24, 0x01	; 1
    20ce:	01 c0       	rjmp	.+2      	; 0x20d2 <prvIsQueueEmpty+0x20>
        }
        else
        {
            xReturn = pdFALSE;
    20d0:	80 e0       	ldi	r24, 0x00	; 0
        }
    }
    taskEXIT_CRITICAL();
    20d2:	0f 90       	pop	r0
    20d4:	0f be       	out	0x3f, r0	; 63

    return xReturn;
}
    20d6:	08 95       	ret

Disassembly of section .text.prvIsQueueFull:

00001f56 <prvIsQueueFull>:

static BaseType_t prvIsQueueFull( const Queue_t * pxQueue )
{
    BaseType_t xReturn;

    taskENTER_CRITICAL();
    1f56:	0f b6       	in	r0, 0x3f	; 63
    1f58:	f8 94       	cli
    1f5a:	0f 92       	push	r0
    {
        if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    1f5c:	9b 01       	movw	r18, r22
    1f5e:	48 2f       	mov	r20, r24
    1f60:	26 5e       	subi	r18, 0xE6	; 230
    1f62:	3f 4f       	sbci	r19, 0xFF	; 255
    1f64:	4f 4f       	sbci	r20, 0xFF	; 255
    1f66:	f9 01       	movw	r30, r18
    1f68:	24 91       	lpm	r18, Z
    1f6a:	47 fd       	sbrc	r20, 7
    1f6c:	20 81       	ld	r18, Z
    1f6e:	a8 2f       	mov	r26, r24
    1f70:	cb 01       	movw	r24, r22
    1f72:	4b 96       	adiw	r24, 0x1b	; 27
    1f74:	a1 1d       	adc	r26, r1
    1f76:	fc 01       	movw	r30, r24
    1f78:	84 91       	lpm	r24, Z
    1f7a:	a7 fd       	sbrc	r26, 7
    1f7c:	80 81       	ld	r24, Z
    1f7e:	28 13       	cpse	r18, r24
    1f80:	02 c0       	rjmp	.+4      	; 0x1f86 <prvIsQueueFull+0x30>
        {
            xReturn = pdTRUE;
    1f82:	81 e0       	ldi	r24, 0x01	; 1
    1f84:	01 c0       	rjmp	.+2      	; 0x1f88 <prvIsQueueFull+0x32>
        }
        else
        {
            xReturn = pdFALSE;
    1f86:	80 e0       	ldi	r24, 0x00	; 0
        }
    }
    taskEXIT_CRITICAL();
    1f88:	0f 90       	pop	r0
    1f8a:	0f be       	out	0x3f, r0	; 63

    return xReturn;
}
    1f8c:	08 95       	ret

Disassembly of section .text.prvCopyDataToQueue:

000014c6 <prvCopyDataToQueue>:
    {
        xReturn = pdFALSE;
    }

    return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    14c6:	0f 93       	push	r16
    14c8:	1f 93       	push	r17
    14ca:	cf 93       	push	r28
    14cc:	df 93       	push	r29
    14ce:	ec 01       	movw	r28, r24
    14d0:	02 2f       	mov	r16, r18
    14d2:	1a 8d       	ldd	r17, Y+26	; 0x1a
    14d4:	2c 8d       	ldd	r18, Y+28	; 0x1c
    14d6:	22 23       	and	r18, r18
    14d8:	b9 f1       	breq	.+110    	; 0x1548 <prvCopyDataToQueue+0x82>
    14da:	01 11       	cpse	r16, r1
    14dc:	16 c0       	rjmp	.+44     	; 0x150a <prvCopyDataToQueue+0x44>
    14de:	30 e0       	ldi	r19, 0x00	; 0
    14e0:	8a 81       	ldd	r24, Y+2	; 0x02
    14e2:	9b 81       	ldd	r25, Y+3	; 0x03
    14e4:	0e 94 17 10 	call	0x202e	; 0x202e <memcpy>
    14e8:	2c 8d       	ldd	r18, Y+28	; 0x1c
    14ea:	8a 81       	ldd	r24, Y+2	; 0x02
    14ec:	9b 81       	ldd	r25, Y+3	; 0x03
    14ee:	82 0f       	add	r24, r18
    14f0:	91 1d       	adc	r25, r1
    14f2:	9b 83       	std	Y+3, r25	; 0x03
    14f4:	8a 83       	std	Y+2, r24	; 0x02
    14f6:	2c 81       	ldd	r18, Y+4	; 0x04
    14f8:	3d 81       	ldd	r19, Y+5	; 0x05
    14fa:	82 17       	cp	r24, r18
    14fc:	93 07       	cpc	r25, r19
    14fe:	20 f1       	brcs	.+72     	; 0x1548 <prvCopyDataToQueue+0x82>
    1500:	88 81       	ld	r24, Y
    1502:	99 81       	ldd	r25, Y+1	; 0x01
    1504:	9b 83       	std	Y+3, r25	; 0x03
    1506:	8a 83       	std	Y+2, r24	; 0x02
    1508:	1f c0       	rjmp	.+62     	; 0x1548 <prvCopyDataToQueue+0x82>
    150a:	30 e0       	ldi	r19, 0x00	; 0
    150c:	8e 81       	ldd	r24, Y+6	; 0x06
    150e:	9f 81       	ldd	r25, Y+7	; 0x07
    1510:	0e 94 17 10 	call	0x202e	; 0x202e <memcpy>
    1514:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1516:	90 e0       	ldi	r25, 0x00	; 0
    1518:	91 95       	neg	r25
    151a:	81 95       	neg	r24
    151c:	91 09       	sbc	r25, r1
    151e:	2e 81       	ldd	r18, Y+6	; 0x06
    1520:	3f 81       	ldd	r19, Y+7	; 0x07
    1522:	28 0f       	add	r18, r24
    1524:	39 1f       	adc	r19, r25
    1526:	3f 83       	std	Y+7, r19	; 0x07
    1528:	2e 83       	std	Y+6, r18	; 0x06
    152a:	48 81       	ld	r20, Y
    152c:	59 81       	ldd	r21, Y+1	; 0x01
    152e:	24 17       	cp	r18, r20
    1530:	35 07       	cpc	r19, r21
    1532:	30 f4       	brcc	.+12     	; 0x1540 <prvCopyDataToQueue+0x7a>
    1534:	2c 81       	ldd	r18, Y+4	; 0x04
    1536:	3d 81       	ldd	r19, Y+5	; 0x05
    1538:	82 0f       	add	r24, r18
    153a:	93 1f       	adc	r25, r19
    153c:	9f 83       	std	Y+7, r25	; 0x07
    153e:	8e 83       	std	Y+6, r24	; 0x06
    1540:	02 30       	cpi	r16, 0x02	; 2
    1542:	11 f4       	brne	.+4      	; 0x1548 <prvCopyDataToQueue+0x82>
    1544:	11 11       	cpse	r17, r1
    1546:	11 50       	subi	r17, 0x01	; 1
    1548:	1f 5f       	subi	r17, 0xFF	; 255
    154a:	1a 8f       	std	Y+26, r17	; 0x1a
    154c:	80 e0       	ldi	r24, 0x00	; 0
    154e:	df 91       	pop	r29
    1550:	cf 91       	pop	r28
    1552:	1f 91       	pop	r17
    1554:	0f 91       	pop	r16
    1556:	08 95       	ret

Disassembly of section .text.prvCopyDataFromQueue:

00001fc6 <prvCopyDataFromQueue>:
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue,
                                  void * const pvBuffer )
{
    1fc6:	fc 01       	movw	r30, r24
    if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    1fc8:	24 8d       	ldd	r18, Z+28	; 0x1c
    1fca:	22 23       	and	r18, r18
    1fcc:	b1 f0       	breq	.+44     	; 0x1ffa <prvCopyDataFromQueue+0x34>
    {
        pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;           /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    1fce:	30 e0       	ldi	r19, 0x00	; 0
    1fd0:	46 81       	ldd	r20, Z+6	; 0x06
    1fd2:	57 81       	ldd	r21, Z+7	; 0x07
    1fd4:	42 0f       	add	r20, r18
    1fd6:	53 1f       	adc	r21, r19
    1fd8:	57 83       	std	Z+7, r21	; 0x07
    1fda:	46 83       	std	Z+6, r20	; 0x06

        if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    1fdc:	84 81       	ldd	r24, Z+4	; 0x04
    1fde:	95 81       	ldd	r25, Z+5	; 0x05
    1fe0:	48 17       	cp	r20, r24
    1fe2:	59 07       	cpc	r21, r25
    1fe4:	20 f0       	brcs	.+8      	; 0x1fee <prvCopyDataFromQueue+0x28>
        {
            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    1fe6:	80 81       	ld	r24, Z
    1fe8:	91 81       	ldd	r25, Z+1	; 0x01
    1fea:	97 83       	std	Z+7, r25	; 0x07
    1fec:	86 83       	std	Z+6, r24	; 0x06
    1fee:	cb 01       	movw	r24, r22
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    1ff0:	46 81       	ldd	r20, Z+6	; 0x06
    1ff2:	57 81       	ldd	r21, Z+7	; 0x07
    1ff4:	60 e8       	ldi	r22, 0x80	; 128
    1ff6:	0e 94 17 10 	call	0x202e	; 0x202e <memcpy>
    1ffa:	08 95       	ret

Disassembly of section .text.prvNotifyQueueSetContainer:

0000142e <prvNotifyQueueSetContainer>:
    {
        xReturn = pdFALSE;
    }

    return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    142e:	ef 92       	push	r14
    1430:	ff 92       	push	r15
    1432:	0f 93       	push	r16
    1434:	1f 93       	push	r17
    1436:	cf 93       	push	r28
    1438:	df 93       	push	r29
    143a:	00 d0       	rcall	.+0      	; 0x143c <prvNotifyQueueSetContainer+0xe>
    143c:	0f 92       	push	r0
    143e:	cd b7       	in	r28, 0x3d	; 61
    1440:	de b7       	in	r29, 0x3e	; 62
    1442:	69 83       	std	Y+1, r22	; 0x01
    1444:	7a 83       	std	Y+2, r23	; 0x02
    1446:	8b 83       	std	Y+3, r24	; 0x03
    1448:	a8 2f       	mov	r26, r24
    144a:	cb 01       	movw	r24, r22
    144c:	4f 96       	adiw	r24, 0x1f	; 31
    144e:	a1 1d       	adc	r26, r1
    1450:	fc 01       	movw	r30, r24
    1452:	5a 2f       	mov	r21, r26
    1454:	0e 94 ee 10 	call	0x21dc	; 0x21dc <__xload_2>
    1458:	fb 01       	movw	r30, r22
    145a:	92 8d       	ldd	r25, Z+26	; 0x1a
    145c:	83 8d       	ldd	r24, Z+27	; 0x1b
    145e:	98 17       	cp	r25, r24
    1460:	18 f5       	brcc	.+70     	; 0x14a8 <prvNotifyQueueSetContainer+0x7a>
    1462:	8b 01       	movw	r16, r22
    1464:	e6 8c       	ldd	r14, Z+30	; 0x1e
    1466:	ae 01       	movw	r20, r28
    1468:	4f 5f       	subi	r20, 0xFF	; 255
    146a:	5f 4f       	sbci	r21, 0xFF	; 255
    146c:	60 e8       	ldi	r22, 0x80	; 128
    146e:	20 e0       	ldi	r18, 0x00	; 0
    1470:	cf 01       	movw	r24, r30
    1472:	0e 94 63 0a 	call	0x14c6	; 0x14c6 <prvCopyDataToQueue>
    1476:	f8 2e       	mov	r15, r24
    1478:	ff ef       	ldi	r31, 0xFF	; 255
    147a:	ef 12       	cpse	r14, r31
    147c:	0d c0       	rjmp	.+26     	; 0x1498 <prvNotifyQueueSetContainer+0x6a>
    147e:	f8 01       	movw	r30, r16
    1480:	81 89       	ldd	r24, Z+17	; 0x11
    1482:	88 23       	and	r24, r24
    1484:	a9 f0       	breq	.+42     	; 0x14b0 <prvNotifyQueueSetContainer+0x82>
    1486:	b8 01       	movw	r22, r16
    1488:	6f 5e       	subi	r22, 0xEF	; 239
    148a:	7f 4f       	sbci	r23, 0xFF	; 255
    148c:	80 e8       	ldi	r24, 0x80	; 128
    148e:	0e 94 62 02 	call	0x4c4	; 0x4c4 <xTaskRemoveFromEventList>
    1492:	81 11       	cpse	r24, r1
    1494:	0b c0       	rjmp	.+22     	; 0x14ac <prvNotifyQueueSetContainer+0x7e>
    1496:	0c c0       	rjmp	.+24     	; 0x14b0 <prvNotifyQueueSetContainer+0x82>
    1498:	0e 94 1b 11 	call	0x2236	; 0x2236 <uxTaskGetNumberOfTasks>
    149c:	e8 16       	cp	r14, r24
    149e:	40 f4       	brcc	.+16     	; 0x14b0 <prvNotifyQueueSetContainer+0x82>
    14a0:	e3 94       	inc	r14
    14a2:	f8 01       	movw	r30, r16
    14a4:	e6 8e       	std	Z+30, r14	; 0x1e
    14a6:	04 c0       	rjmp	.+8      	; 0x14b0 <prvNotifyQueueSetContainer+0x82>
    14a8:	f1 2c       	mov	r15, r1
    14aa:	02 c0       	rjmp	.+4      	; 0x14b0 <prvNotifyQueueSetContainer+0x82>
    14ac:	ff 24       	eor	r15, r15
    14ae:	f3 94       	inc	r15
    14b0:	8f 2d       	mov	r24, r15
    14b2:	0f 90       	pop	r0
    14b4:	0f 90       	pop	r0
    14b6:	0f 90       	pop	r0
    14b8:	df 91       	pop	r29
    14ba:	cf 91       	pop	r28
    14bc:	1f 91       	pop	r17
    14be:	0f 91       	pop	r16
    14c0:	ff 90       	pop	r15
    14c2:	ef 90       	pop	r14
    14c4:	08 95       	ret

Disassembly of section .text.prvUnlockQueue:

0000167a <prvUnlockQueue>:
    167a:	1f 93       	push	r17
    167c:	cf 93       	push	r28
    167e:	df 93       	push	r29
    1680:	ec 01       	movw	r28, r24
    1682:	0f b6       	in	r0, 0x3f	; 63
    1684:	f8 94       	cli
    1686:	0f 92       	push	r0
    1688:	1e 8d       	ldd	r17, Y+30	; 0x1e
    168a:	1a c0       	rjmp	.+52     	; 0x16c0 <prvUnlockQueue+0x46>
    168c:	8f 8d       	ldd	r24, Y+31	; 0x1f
    168e:	98 a1       	ldd	r25, Y+32	; 0x20
    1690:	89 2b       	or	r24, r25
    1692:	49 f0       	breq	.+18     	; 0x16a6 <prvUnlockQueue+0x2c>
    1694:	be 01       	movw	r22, r28
    1696:	80 e8       	ldi	r24, 0x80	; 128
    1698:	0e 94 17 0a 	call	0x142e	; 0x142e <prvNotifyQueueSetContainer>
    169c:	88 23       	and	r24, r24
    169e:	79 f0       	breq	.+30     	; 0x16be <prvUnlockQueue+0x44>
    16a0:	0e 94 11 11 	call	0x2222	; 0x2222 <vTaskMissedYield>
    16a4:	0c c0       	rjmp	.+24     	; 0x16be <prvUnlockQueue+0x44>
    16a6:	89 89       	ldd	r24, Y+17	; 0x11
    16a8:	88 23       	and	r24, r24
    16aa:	61 f0       	breq	.+24     	; 0x16c4 <prvUnlockQueue+0x4a>
    16ac:	be 01       	movw	r22, r28
    16ae:	6f 5e       	subi	r22, 0xEF	; 239
    16b0:	7f 4f       	sbci	r23, 0xFF	; 255
    16b2:	80 e8       	ldi	r24, 0x80	; 128
    16b4:	0e 94 62 02 	call	0x4c4	; 0x4c4 <xTaskRemoveFromEventList>
    16b8:	81 11       	cpse	r24, r1
    16ba:	0e 94 11 11 	call	0x2222	; 0x2222 <vTaskMissedYield>
    16be:	11 50       	subi	r17, 0x01	; 1
    16c0:	11 16       	cp	r1, r17
    16c2:	24 f3       	brlt	.-56     	; 0x168c <prvUnlockQueue+0x12>
    16c4:	8f ef       	ldi	r24, 0xFF	; 255
    16c6:	8e 8f       	std	Y+30, r24	; 0x1e
    16c8:	0f 90       	pop	r0
    16ca:	0f be       	out	0x3f, r0	; 63
    16cc:	0f b6       	in	r0, 0x3f	; 63
    16ce:	f8 94       	cli
    16d0:	0f 92       	push	r0
    16d2:	1d 8d       	ldd	r17, Y+29	; 0x1d
    16d4:	0d c0       	rjmp	.+26     	; 0x16f0 <prvUnlockQueue+0x76>
    16d6:	88 85       	ldd	r24, Y+8	; 0x08
    16d8:	88 23       	and	r24, r24
    16da:	61 f0       	breq	.+24     	; 0x16f4 <prvUnlockQueue+0x7a>
    16dc:	be 01       	movw	r22, r28
    16de:	68 5f       	subi	r22, 0xF8	; 248
    16e0:	7f 4f       	sbci	r23, 0xFF	; 255
    16e2:	80 e8       	ldi	r24, 0x80	; 128
    16e4:	0e 94 62 02 	call	0x4c4	; 0x4c4 <xTaskRemoveFromEventList>
    16e8:	81 11       	cpse	r24, r1
    16ea:	0e 94 11 11 	call	0x2222	; 0x2222 <vTaskMissedYield>
    16ee:	11 50       	subi	r17, 0x01	; 1
    16f0:	11 16       	cp	r1, r17
    16f2:	8c f3       	brlt	.-30     	; 0x16d6 <prvUnlockQueue+0x5c>
    16f4:	8f ef       	ldi	r24, 0xFF	; 255
    16f6:	8d 8f       	std	Y+29, r24	; 0x1d
    16f8:	0f 90       	pop	r0
    16fa:	0f be       	out	0x3f, r0	; 63
    16fc:	df 91       	pop	r29
    16fe:	cf 91       	pop	r28
    1700:	1f 91       	pop	r17
    1702:	08 95       	ret

Disassembly of section .text.xQueueGenericReset:

00000f60 <xQueueGenericReset>:
     f60:	0f 93       	push	r16
     f62:	1f 93       	push	r17
     f64:	cf 93       	push	r28
     f66:	df 93       	push	r29
     f68:	fc 01       	movw	r30, r24
     f6a:	36 2f       	mov	r19, r22
     f6c:	89 2b       	or	r24, r25
     f6e:	09 f4       	brne	.+2      	; 0xf72 <xQueueGenericReset+0x12>
     f70:	4e c0       	rjmp	.+156    	; 0x100e <xQueueGenericReset+0xae>
     f72:	23 8d       	ldd	r18, Z+27	; 0x1b
     f74:	22 23       	and	r18, r18
     f76:	09 f4       	brne	.+2      	; 0xf7a <xQueueGenericReset+0x1a>
     f78:	4c c0       	rjmp	.+152    	; 0x1012 <xQueueGenericReset+0xb2>
     f7a:	02 2f       	mov	r16, r18
     f7c:	10 e0       	ldi	r17, 0x00	; 0
     f7e:	8f ef       	ldi	r24, 0xFF	; 255
     f80:	9f ef       	ldi	r25, 0xFF	; 255
     f82:	b8 01       	movw	r22, r16
     f84:	0e 94 45 10 	call	0x208a	; 0x208a <__udivmodhi4>
     f88:	44 8d       	ldd	r20, Z+28	; 0x1c
     f8a:	84 2f       	mov	r24, r20
     f8c:	90 e0       	ldi	r25, 0x00	; 0
     f8e:	68 17       	cp	r22, r24
     f90:	79 07       	cpc	r23, r25
     f92:	08 f4       	brcc	.+2      	; 0xf96 <xQueueGenericReset+0x36>
     f94:	40 c0       	rjmp	.+128    	; 0x1016 <xQueueGenericReset+0xb6>
     f96:	ef 01       	movw	r28, r30
     f98:	0f b6       	in	r0, 0x3f	; 63
     f9a:	f8 94       	cli
     f9c:	0f 92       	push	r0
     f9e:	60 81       	ld	r22, Z
     fa0:	71 81       	ldd	r23, Z+1	; 0x01
     fa2:	fb 01       	movw	r30, r22
     fa4:	24 9f       	mul	r18, r20
     fa6:	e0 0d       	add	r30, r0
     fa8:	f1 1d       	adc	r31, r1
     faa:	11 24       	eor	r1, r1
     fac:	fd 83       	std	Y+5, r31	; 0x05
     fae:	ec 83       	std	Y+4, r30	; 0x04
     fb0:	1a 8e       	std	Y+26, r1	; 0x1a
     fb2:	7b 83       	std	Y+3, r23	; 0x03
     fb4:	6a 83       	std	Y+2, r22	; 0x02
     fb6:	01 50       	subi	r16, 0x01	; 1
     fb8:	11 09       	sbc	r17, r1
     fba:	80 9f       	mul	r24, r16
     fbc:	a0 01       	movw	r20, r0
     fbe:	81 9f       	mul	r24, r17
     fc0:	50 0d       	add	r21, r0
     fc2:	90 9f       	mul	r25, r16
     fc4:	50 0d       	add	r21, r0
     fc6:	11 24       	eor	r1, r1
     fc8:	cb 01       	movw	r24, r22
     fca:	84 0f       	add	r24, r20
     fcc:	95 1f       	adc	r25, r21
     fce:	9f 83       	std	Y+7, r25	; 0x07
     fd0:	8e 83       	std	Y+6, r24	; 0x06
     fd2:	8f ef       	ldi	r24, 0xFF	; 255
     fd4:	8d 8f       	std	Y+29, r24	; 0x1d
     fd6:	8e 8f       	std	Y+30, r24	; 0x1e
     fd8:	31 11       	cpse	r19, r1
     fda:	0d c0       	rjmp	.+26     	; 0xff6 <xQueueGenericReset+0x96>
     fdc:	88 85       	ldd	r24, Y+8	; 0x08
     fde:	88 23       	and	r24, r24
     fe0:	91 f0       	breq	.+36     	; 0x1006 <xQueueGenericReset+0xa6>
     fe2:	28 96       	adiw	r28, 0x08	; 8
     fe4:	be 01       	movw	r22, r28
     fe6:	80 e8       	ldi	r24, 0x80	; 128
     fe8:	0e 94 62 02 	call	0x4c4	; 0x4c4 <xTaskRemoveFromEventList>
     fec:	88 23       	and	r24, r24
     fee:	59 f0       	breq	.+22     	; 0x1006 <xQueueGenericReset+0xa6>
     ff0:	0e 94 cb 08 	call	0x1196	; 0x1196 <vPortYield>
     ff4:	08 c0       	rjmp	.+16     	; 0x1006 <xQueueGenericReset+0xa6>
     ff6:	ce 01       	movw	r24, r28
     ff8:	08 96       	adiw	r24, 0x08	; 8
     ffa:	0e 94 9c 10 	call	0x2138	; 0x2138 <vListInitialise>
     ffe:	ce 01       	movw	r24, r28
    1000:	41 96       	adiw	r24, 0x11	; 17
    1002:	0e 94 9c 10 	call	0x2138	; 0x2138 <vListInitialise>
    1006:	0f 90       	pop	r0
    1008:	0f be       	out	0x3f, r0	; 63
    100a:	81 e0       	ldi	r24, 0x01	; 1
    100c:	05 c0       	rjmp	.+10     	; 0x1018 <xQueueGenericReset+0xb8>
    100e:	80 e0       	ldi	r24, 0x00	; 0
    1010:	03 c0       	rjmp	.+6      	; 0x1018 <xQueueGenericReset+0xb8>
    1012:	80 e0       	ldi	r24, 0x00	; 0
    1014:	01 c0       	rjmp	.+2      	; 0x1018 <xQueueGenericReset+0xb8>
    1016:	80 e0       	ldi	r24, 0x00	; 0
    1018:	df 91       	pop	r29
    101a:	cf 91       	pop	r28
    101c:	1f 91       	pop	r17
    101e:	0f 91       	pop	r16
    1020:	08 95       	ret

Disassembly of section .text.prvInitialiseNewQueue:

00001ffc <prvInitialiseNewQueue>:
static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength,
                                   const UBaseType_t uxItemSize,
                                   uint8_t * pucQueueStorage,
                                   const uint8_t ucQueueType,
                                   Queue_t * pxNewQueue )
{
    1ffc:	0f 93       	push	r16
    1ffe:	1f 93       	push	r17
    2000:	cf 93       	push	r28
    2002:	df 93       	push	r29
    2004:	e8 01       	movw	r28, r16
    /* Remove compiler warnings about unused parameters should
     * configUSE_TRACE_FACILITY not be set to 1. */
    ( void ) ucQueueType;

    if( uxItemSize == ( UBaseType_t ) 0 )
    2006:	61 11       	cpse	r22, r1
    2008:	03 c0       	rjmp	.+6      	; 0x2010 <prvInitialiseNewQueue+0x14>
    {
        /* No RAM was allocated for the queue storage area, but PC head cannot
         * be set to NULL because NULL is used as a key to say the queue is used as
         * a mutex.  Therefore just set pcHead to point to the queue as a benign
         * value that is known to be within the memory map. */
        pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    200a:	19 83       	std	Y+1, r17	; 0x01
    200c:	08 83       	st	Y, r16
    200e:	02 c0       	rjmp	.+4      	; 0x2014 <prvInitialiseNewQueue+0x18>
    }
    else
    {
        /* Set the head to the start of the queue storage area. */
        pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
    2010:	59 83       	std	Y+1, r21	; 0x01
    2012:	48 83       	st	Y, r20
    }

    /* Initialise the queue members as described where the queue type is
     * defined. */
    pxNewQueue->uxLength = uxQueueLength;
    2014:	8b 8f       	std	Y+27, r24	; 0x1b
    pxNewQueue->uxItemSize = uxItemSize;
    2016:	6c 8f       	std	Y+28, r22	; 0x1c
    ( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    2018:	61 e0       	ldi	r22, 0x01	; 1
    201a:	ce 01       	movw	r24, r28
    201c:	0e 94 b0 07 	call	0xf60	; 0xf60 <xQueueGenericReset>
    }
    #endif /* configUSE_TRACE_FACILITY */

    #if ( configUSE_QUEUE_SETS == 1 )
    {
        pxNewQueue->pxQueueSetContainer = NULL;
    2020:	18 a2       	std	Y+32, r1	; 0x20
    2022:	1f 8e       	std	Y+31, r1	; 0x1f
    }
    #endif /* configUSE_QUEUE_SETS */

    traceQUEUE_CREATE( pxNewQueue );
}
    2024:	df 91       	pop	r29
    2026:	cf 91       	pop	r28
    2028:	1f 91       	pop	r17
    202a:	0f 91       	pop	r16
    202c:	08 95       	ret

Disassembly of section .text.xQueueGenericCreate:

00001704 <xQueueGenericCreate>:
    {
        xReturn = pdFALSE;
    }

    return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    1704:	df 92       	push	r13
    1706:	ef 92       	push	r14
    1708:	ff 92       	push	r15
    170a:	0f 93       	push	r16
    170c:	1f 93       	push	r17
    170e:	cf 93       	push	r28
    1710:	df 93       	push	r29
    1712:	38 2f       	mov	r19, r24
    1714:	e6 2f       	mov	r30, r22
    1716:	88 23       	and	r24, r24
    1718:	29 f1       	breq	.+74     	; 0x1764 <xQueueGenericCreate+0x60>
    171a:	68 2f       	mov	r22, r24
    171c:	70 e0       	ldi	r23, 0x00	; 0
    171e:	8f ef       	ldi	r24, 0xFF	; 255
    1720:	9f ef       	ldi	r25, 0xFF	; 255
    1722:	0e 94 45 10 	call	0x208a	; 0x208a <__udivmodhi4>
    1726:	8e 2f       	mov	r24, r30
    1728:	90 e0       	ldi	r25, 0x00	; 0
    172a:	68 17       	cp	r22, r24
    172c:	79 07       	cpc	r23, r25
    172e:	e8 f0       	brcs	.+58     	; 0x176a <xQueueGenericCreate+0x66>
    1730:	3e 9f       	mul	r19, r30
    1732:	c0 01       	movw	r24, r0
    1734:	11 24       	eor	r1, r1
    1736:	8f 3d       	cpi	r24, 0xDF	; 223
    1738:	2f ef       	ldi	r18, 0xFF	; 255
    173a:	92 07       	cpc	r25, r18
    173c:	c8 f4       	brcc	.+50     	; 0x1770 <xQueueGenericCreate+0x6c>
    173e:	d4 2e       	mov	r13, r20
    1740:	de 2f       	mov	r29, r30
    1742:	c3 2f       	mov	r28, r19
    1744:	81 96       	adiw	r24, 0x21	; 33
    1746:	0e 94 3d 0c 	call	0x187a	; 0x187a <pvPortMalloc>
    174a:	7c 01       	movw	r14, r24
    174c:	00 97       	sbiw	r24, 0x00	; 0
    174e:	91 f0       	breq	.+36     	; 0x1774 <xQueueGenericCreate+0x70>
    1750:	8c 01       	movw	r16, r24
    1752:	2d 2d       	mov	r18, r13
    1754:	ac 01       	movw	r20, r24
    1756:	4f 5d       	subi	r20, 0xDF	; 223
    1758:	5f 4f       	sbci	r21, 0xFF	; 255
    175a:	6d 2f       	mov	r22, r29
    175c:	8c 2f       	mov	r24, r28
    175e:	0e 94 fe 0f 	call	0x1ffc	; 0x1ffc <prvInitialiseNewQueue>
    1762:	08 c0       	rjmp	.+16     	; 0x1774 <xQueueGenericCreate+0x70>
    1764:	e1 2c       	mov	r14, r1
    1766:	f1 2c       	mov	r15, r1
    1768:	05 c0       	rjmp	.+10     	; 0x1774 <xQueueGenericCreate+0x70>
    176a:	e1 2c       	mov	r14, r1
    176c:	f1 2c       	mov	r15, r1
    176e:	02 c0       	rjmp	.+4      	; 0x1774 <xQueueGenericCreate+0x70>
    1770:	e1 2c       	mov	r14, r1
    1772:	f1 2c       	mov	r15, r1
    1774:	c7 01       	movw	r24, r14
    1776:	df 91       	pop	r29
    1778:	cf 91       	pop	r28
    177a:	1f 91       	pop	r17
    177c:	0f 91       	pop	r16
    177e:	ff 90       	pop	r15
    1780:	ef 90       	pop	r14
    1782:	df 90       	pop	r13
    1784:	08 95       	ret

Disassembly of section .text.xQueueGenericSend:

00000648 <xQueueGenericSend>:
 648:	6f 92       	push	r6
 64a:	7f 92       	push	r7
 64c:	8f 92       	push	r8
 64e:	ef 92       	push	r14
 650:	ff 92       	push	r15
 652:	0f 93       	push	r16
 654:	1f 93       	push	r17
 656:	cf 93       	push	r28
 658:	df 93       	push	r29
 65a:	00 d0       	rcall	.+0      	; 0x65c <xQueueGenericSend+0x14>
 65c:	00 d0       	rcall	.+0      	; 0x65e <xQueueGenericSend+0x16>
 65e:	0f 92       	push	r0
 660:	cd b7       	in	r28, 0x3d	; 61
 662:	de b7       	in	r29, 0x3e	; 62
 664:	7c 01       	movw	r14, r24
 666:	3a 01       	movw	r6, r20
 668:	86 2e       	mov	r8, r22
 66a:	3d 83       	std	Y+5, r19	; 0x05
 66c:	2c 83       	std	Y+4, r18	; 0x04
 66e:	10 e0       	ldi	r17, 0x00	; 0
 670:	0f b6       	in	r0, 0x3f	; 63
 672:	f8 94       	cli
 674:	0f 92       	push	r0
 676:	f7 01       	movw	r30, r14
 678:	92 8d       	ldd	r25, Z+26	; 0x1a
 67a:	83 8d       	ldd	r24, Z+27	; 0x1b
 67c:	98 17       	cp	r25, r24
 67e:	10 f0       	brcs	.+4      	; 0x684 <xQueueGenericSend+0x3c>
 680:	02 30       	cpi	r16, 0x02	; 2
 682:	81 f5       	brne	.+96     	; 0x6e4 <xQueueGenericSend+0x9c>
 684:	f7 01       	movw	r30, r14
 686:	12 8d       	ldd	r17, Z+26	; 0x1a
 688:	20 2f       	mov	r18, r16
 68a:	68 2d       	mov	r22, r8
 68c:	a3 01       	movw	r20, r6
 68e:	c7 01       	movw	r24, r14
 690:	0e 94 63 0a 	call	0x14c6	; 0x14c6 <prvCopyDataToQueue>
 694:	f7 01       	movw	r30, r14
 696:	27 8d       	ldd	r18, Z+31	; 0x1f
 698:	30 a1       	ldd	r19, Z+32	; 0x20
 69a:	23 2b       	or	r18, r19
 69c:	69 f0       	breq	.+26     	; 0x6b8 <xQueueGenericSend+0x70>
 69e:	02 30       	cpi	r16, 0x02	; 2
 6a0:	11 f4       	brne	.+4      	; 0x6a6 <xQueueGenericSend+0x5e>
 6a2:	11 11       	cpse	r17, r1
 6a4:	1b c0       	rjmp	.+54     	; 0x6dc <xQueueGenericSend+0x94>
 6a6:	b7 01       	movw	r22, r14
 6a8:	80 e8       	ldi	r24, 0x80	; 128
 6aa:	0e 94 17 0a 	call	0x142e	; 0x142e <prvNotifyQueueSetContainer>
 6ae:	88 23       	and	r24, r24
 6b0:	a9 f0       	breq	.+42     	; 0x6dc <xQueueGenericSend+0x94>
 6b2:	0e 94 cb 08 	call	0x1196	; 0x1196 <vPortYield>
 6b6:	12 c0       	rjmp	.+36     	; 0x6dc <xQueueGenericSend+0x94>
 6b8:	f7 01       	movw	r30, r14
 6ba:	91 89       	ldd	r25, Z+17	; 0x11
 6bc:	99 23       	and	r25, r25
 6be:	59 f0       	breq	.+22     	; 0x6d6 <xQueueGenericSend+0x8e>
 6c0:	b7 01       	movw	r22, r14
 6c2:	6f 5e       	subi	r22, 0xEF	; 239
 6c4:	7f 4f       	sbci	r23, 0xFF	; 255
 6c6:	80 e8       	ldi	r24, 0x80	; 128
 6c8:	0e 94 62 02 	call	0x4c4	; 0x4c4 <xTaskRemoveFromEventList>
 6cc:	88 23       	and	r24, r24
 6ce:	31 f0       	breq	.+12     	; 0x6dc <xQueueGenericSend+0x94>
 6d0:	0e 94 cb 08 	call	0x1196	; 0x1196 <vPortYield>
 6d4:	03 c0       	rjmp	.+6      	; 0x6dc <xQueueGenericSend+0x94>
 6d6:	81 11       	cpse	r24, r1
 6d8:	0e 94 cb 08 	call	0x1196	; 0x1196 <vPortYield>
 6dc:	0f 90       	pop	r0
 6de:	0f be       	out	0x3f, r0	; 63
 6e0:	81 e0       	ldi	r24, 0x01	; 1
 6e2:	4d c0       	rjmp	.+154    	; 0x77e <xQueueGenericSend+0x136>
 6e4:	8c 81       	ldd	r24, Y+4	; 0x04
 6e6:	9d 81       	ldd	r25, Y+5	; 0x05
 6e8:	89 2b       	or	r24, r25
 6ea:	21 f4       	brne	.+8      	; 0x6f4 <xQueueGenericSend+0xac>
 6ec:	0f 90       	pop	r0
 6ee:	0f be       	out	0x3f, r0	; 63
 6f0:	80 e0       	ldi	r24, 0x00	; 0
 6f2:	45 c0       	rjmp	.+138    	; 0x77e <xQueueGenericSend+0x136>
 6f4:	11 11       	cpse	r17, r1
 6f6:	05 c0       	rjmp	.+10     	; 0x702 <xQueueGenericSend+0xba>
 6f8:	ce 01       	movw	r24, r28
 6fa:	01 96       	adiw	r24, 0x01	; 1
 6fc:	0e 94 c5 10 	call	0x218a	; 0x218a <vTaskInternalSetTimeOutState>
 700:	11 e0       	ldi	r17, 0x01	; 1
 702:	0f 90       	pop	r0
 704:	0f be       	out	0x3f, r0	; 63
 706:	0e 94 fc 10 	call	0x21f8	; 0x21f8 <vTaskSuspendAll>
 70a:	0f b6       	in	r0, 0x3f	; 63
 70c:	f8 94       	cli
 70e:	0f 92       	push	r0
 710:	f7 01       	movw	r30, r14
 712:	85 8d       	ldd	r24, Z+29	; 0x1d
 714:	8f 3f       	cpi	r24, 0xFF	; 255
 716:	09 f4       	brne	.+2      	; 0x71a <xQueueGenericSend+0xd2>
 718:	15 8e       	std	Z+29, r1	; 0x1d
 71a:	f7 01       	movw	r30, r14
 71c:	86 8d       	ldd	r24, Z+30	; 0x1e
 71e:	8f 3f       	cpi	r24, 0xFF	; 255
 720:	09 f4       	brne	.+2      	; 0x724 <xQueueGenericSend+0xdc>
 722:	16 8e       	std	Z+30, r1	; 0x1e
 724:	0f 90       	pop	r0
 726:	0f be       	out	0x3f, r0	; 63
 728:	be 01       	movw	r22, r28
 72a:	6c 5f       	subi	r22, 0xFC	; 252
 72c:	7f 4f       	sbci	r23, 0xFF	; 255
 72e:	ce 01       	movw	r24, r28
 730:	01 96       	adiw	r24, 0x01	; 1
 732:	0e 94 c3 0b 	call	0x1786	; 0x1786 <xTaskCheckForTimeOut>
 736:	81 11       	cpse	r24, r1
 738:	1c c0       	rjmp	.+56     	; 0x772 <xQueueGenericSend+0x12a>
 73a:	b7 01       	movw	r22, r14
 73c:	80 e8       	ldi	r24, 0x80	; 128
 73e:	0e 94 ab 0f 	call	0x1f56	; 0x1f56 <prvIsQueueFull>
 742:	88 23       	and	r24, r24
 744:	81 f0       	breq	.+32     	; 0x766 <xQueueGenericSend+0x11e>
 746:	6c 81       	ldd	r22, Y+4	; 0x04
 748:	7d 81       	ldd	r23, Y+5	; 0x05
 74a:	c7 01       	movw	r24, r14
 74c:	08 96       	adiw	r24, 0x08	; 8
 74e:	0e 94 6c 10 	call	0x20d8	; 0x20d8 <vTaskPlaceOnEventList>
 752:	c7 01       	movw	r24, r14
 754:	0e 94 3d 0b 	call	0x167a	; 0x167a <prvUnlockQueue>
 758:	0e 94 8d 01 	call	0x31a	; 0x31a <xTaskResumeAll>
 75c:	81 11       	cpse	r24, r1
 75e:	88 cf       	rjmp	.-240    	; 0x670 <xQueueGenericSend+0x28>
 760:	0e 94 cb 08 	call	0x1196	; 0x1196 <vPortYield>
 764:	85 cf       	rjmp	.-246    	; 0x670 <xQueueGenericSend+0x28>
 766:	c7 01       	movw	r24, r14
 768:	0e 94 3d 0b 	call	0x167a	; 0x167a <prvUnlockQueue>
 76c:	0e 94 8d 01 	call	0x31a	; 0x31a <xTaskResumeAll>
 770:	7f cf       	rjmp	.-258    	; 0x670 <xQueueGenericSend+0x28>
 772:	c7 01       	movw	r24, r14
 774:	0e 94 3d 0b 	call	0x167a	; 0x167a <prvUnlockQueue>
 778:	0e 94 8d 01 	call	0x31a	; 0x31a <xTaskResumeAll>
 77c:	80 e0       	ldi	r24, 0x00	; 0
 77e:	0f 90       	pop	r0
 780:	0f 90       	pop	r0
 782:	0f 90       	pop	r0
 784:	0f 90       	pop	r0
 786:	0f 90       	pop	r0
 788:	df 91       	pop	r29
 78a:	cf 91       	pop	r28
 78c:	1f 91       	pop	r17
 78e:	0f 91       	pop	r16
 790:	ff 90       	pop	r15
 792:	ef 90       	pop	r14
 794:	8f 90       	pop	r8
 796:	7f 90       	pop	r7
 798:	6f 90       	pop	r6
 79a:	08 95       	ret

Disassembly of section .text.xQueueGenericSendFromISR:

00001022 <xQueueGenericSendFromISR>:
    1022:	df 92       	push	r13
    1024:	ef 92       	push	r14
    1026:	ff 92       	push	r15
    1028:	0f 93       	push	r16
    102a:	1f 93       	push	r17
    102c:	cf 93       	push	r28
    102e:	df 93       	push	r29
    1030:	e9 01       	movw	r28, r18
    1032:	fc 01       	movw	r30, r24
    1034:	72 8d       	ldd	r23, Z+26	; 0x1a
    1036:	33 8d       	ldd	r19, Z+27	; 0x1b
    1038:	73 17       	cp	r23, r19
    103a:	10 f0       	brcs	.+4      	; 0x1040 <xQueueGenericSendFromISR+0x1e>
    103c:	02 30       	cpi	r16, 0x02	; 2
    103e:	c1 f5       	brne	.+112    	; 0x10b0 <xQueueGenericSendFromISR+0x8e>
    1040:	7e 01       	movw	r14, r28
    1042:	ec 01       	movw	r28, r24
    1044:	1e 8d       	ldd	r17, Y+30	; 0x1e
    1046:	da 8c       	ldd	r13, Y+26	; 0x1a
    1048:	20 2f       	mov	r18, r16
    104a:	0e 94 63 0a 	call	0x14c6	; 0x14c6 <prvCopyDataToQueue>
    104e:	1f 3f       	cpi	r17, 0xFF	; 255
    1050:	39 f5       	brne	.+78     	; 0x10a0 <xQueueGenericSendFromISR+0x7e>
    1052:	8f 8d       	ldd	r24, Y+31	; 0x1f
    1054:	98 a1       	ldd	r25, Y+32	; 0x20
    1056:	89 2b       	or	r24, r25
    1058:	89 f0       	breq	.+34     	; 0x107c <xQueueGenericSendFromISR+0x5a>
    105a:	02 30       	cpi	r16, 0x02	; 2
    105c:	11 f4       	brne	.+4      	; 0x1062 <xQueueGenericSendFromISR+0x40>
    105e:	d1 10       	cpse	r13, r1
    1060:	29 c0       	rjmp	.+82     	; 0x10b4 <xQueueGenericSendFromISR+0x92>
    1062:	be 01       	movw	r22, r28
    1064:	80 e8       	ldi	r24, 0x80	; 128
    1066:	0e 94 17 0a 	call	0x142e	; 0x142e <prvNotifyQueueSetContainer>
    106a:	88 23       	and	r24, r24
    106c:	29 f1       	breq	.+74     	; 0x10b8 <xQueueGenericSendFromISR+0x96>
    106e:	e1 14       	cp	r14, r1
    1070:	f1 04       	cpc	r15, r1
    1072:	21 f1       	breq	.+72     	; 0x10bc <xQueueGenericSendFromISR+0x9a>
    1074:	81 e0       	ldi	r24, 0x01	; 1
    1076:	f7 01       	movw	r30, r14
    1078:	80 83       	st	Z, r24
    107a:	29 c0       	rjmp	.+82     	; 0x10ce <xQueueGenericSendFromISR+0xac>
    107c:	89 89       	ldd	r24, Y+17	; 0x11
    107e:	88 23       	and	r24, r24
    1080:	f9 f0       	breq	.+62     	; 0x10c0 <xQueueGenericSendFromISR+0x9e>
    1082:	ce 01       	movw	r24, r28
    1084:	41 96       	adiw	r24, 0x11	; 17
    1086:	bc 01       	movw	r22, r24
    1088:	80 e8       	ldi	r24, 0x80	; 128
    108a:	0e 94 62 02 	call	0x4c4	; 0x4c4 <xTaskRemoveFromEventList>
    108e:	88 23       	and	r24, r24
    1090:	c9 f0       	breq	.+50     	; 0x10c4 <xQueueGenericSendFromISR+0xa2>
    1092:	e1 14       	cp	r14, r1
    1094:	f1 04       	cpc	r15, r1
    1096:	c1 f0       	breq	.+48     	; 0x10c8 <xQueueGenericSendFromISR+0xa6>
    1098:	81 e0       	ldi	r24, 0x01	; 1
    109a:	f7 01       	movw	r30, r14
    109c:	80 83       	st	Z, r24
    109e:	17 c0       	rjmp	.+46     	; 0x10ce <xQueueGenericSendFromISR+0xac>
    10a0:	0e 94 1b 11 	call	0x2236	; 0x2236 <uxTaskGetNumberOfTasks>
    10a4:	18 17       	cp	r17, r24
    10a6:	90 f4       	brcc	.+36     	; 0x10cc <xQueueGenericSendFromISR+0xaa>
    10a8:	1f 5f       	subi	r17, 0xFF	; 255
    10aa:	1e 8f       	std	Y+30, r17	; 0x1e
    10ac:	81 e0       	ldi	r24, 0x01	; 1
    10ae:	0f c0       	rjmp	.+30     	; 0x10ce <xQueueGenericSendFromISR+0xac>
    10b0:	80 e0       	ldi	r24, 0x00	; 0
    10b2:	0d c0       	rjmp	.+26     	; 0x10ce <xQueueGenericSendFromISR+0xac>
    10b4:	81 e0       	ldi	r24, 0x01	; 1
    10b6:	0b c0       	rjmp	.+22     	; 0x10ce <xQueueGenericSendFromISR+0xac>
    10b8:	81 e0       	ldi	r24, 0x01	; 1
    10ba:	09 c0       	rjmp	.+18     	; 0x10ce <xQueueGenericSendFromISR+0xac>
    10bc:	81 e0       	ldi	r24, 0x01	; 1
    10be:	07 c0       	rjmp	.+14     	; 0x10ce <xQueueGenericSendFromISR+0xac>
    10c0:	81 e0       	ldi	r24, 0x01	; 1
    10c2:	05 c0       	rjmp	.+10     	; 0x10ce <xQueueGenericSendFromISR+0xac>
    10c4:	81 e0       	ldi	r24, 0x01	; 1
    10c6:	03 c0       	rjmp	.+6      	; 0x10ce <xQueueGenericSendFromISR+0xac>
    10c8:	81 e0       	ldi	r24, 0x01	; 1
    10ca:	01 c0       	rjmp	.+2      	; 0x10ce <xQueueGenericSendFromISR+0xac>
    10cc:	81 e0       	ldi	r24, 0x01	; 1
    10ce:	df 91       	pop	r29
    10d0:	cf 91       	pop	r28
    10d2:	1f 91       	pop	r17
    10d4:	0f 91       	pop	r16
    10d6:	ff 90       	pop	r15
    10d8:	ef 90       	pop	r14
    10da:	df 90       	pop	r13
    10dc:	08 95       	ret

Disassembly of section .text.xQueueReceive:

000008dc <xQueueReceive>:
 8dc:	cf 92       	push	r12
 8de:	df 92       	push	r13
 8e0:	ef 92       	push	r14
 8e2:	ff 92       	push	r15
 8e4:	0f 93       	push	r16
 8e6:	1f 93       	push	r17
 8e8:	cf 93       	push	r28
 8ea:	df 93       	push	r29
 8ec:	00 d0       	rcall	.+0      	; 0x8ee <xQueueReceive+0x12>
 8ee:	00 d0       	rcall	.+0      	; 0x8f0 <xQueueReceive+0x14>
 8f0:	0f 92       	push	r0
 8f2:	cd b7       	in	r28, 0x3d	; 61
 8f4:	de b7       	in	r29, 0x3e	; 62
 8f6:	8c 01       	movw	r16, r24
 8f8:	6b 01       	movw	r12, r22
 8fa:	5d 83       	std	Y+5, r21	; 0x05
 8fc:	4c 83       	std	Y+4, r20	; 0x04
 8fe:	e1 2c       	mov	r14, r1
 900:	0f b6       	in	r0, 0x3f	; 63
 902:	f8 94       	cli
 904:	0f 92       	push	r0
 906:	f8 01       	movw	r30, r16
 908:	f2 8c       	ldd	r15, Z+26	; 0x1a
 90a:	ff 20       	and	r15, r15
 90c:	b9 f0       	breq	.+46     	; 0x93c <xQueueReceive+0x60>
 90e:	b6 01       	movw	r22, r12
 910:	c8 01       	movw	r24, r16
 912:	0e 94 e3 0f 	call	0x1fc6	; 0x1fc6 <prvCopyDataFromQueue>
 916:	fa 94       	dec	r15
 918:	f8 01       	movw	r30, r16
 91a:	f2 8e       	std	Z+26, r15	; 0x1a
 91c:	80 85       	ldd	r24, Z+8	; 0x08
 91e:	88 23       	and	r24, r24
 920:	49 f0       	breq	.+18     	; 0x934 <xQueueReceive+0x58>
 922:	08 5f       	subi	r16, 0xF8	; 248
 924:	1f 4f       	sbci	r17, 0xFF	; 255
 926:	b8 01       	movw	r22, r16
 928:	80 e8       	ldi	r24, 0x80	; 128
 92a:	0e 94 62 02 	call	0x4c4	; 0x4c4 <xTaskRemoveFromEventList>
 92e:	81 11       	cpse	r24, r1
 930:	0e 94 cb 08 	call	0x1196	; 0x1196 <vPortYield>
 934:	0f 90       	pop	r0
 936:	0f be       	out	0x3f, r0	; 63
 938:	81 e0       	ldi	r24, 0x01	; 1
 93a:	55 c0       	rjmp	.+170    	; 0x9e6 <xQueueReceive+0x10a>
 93c:	8c 81       	ldd	r24, Y+4	; 0x04
 93e:	9d 81       	ldd	r25, Y+5	; 0x05
 940:	89 2b       	or	r24, r25
 942:	21 f4       	brne	.+8      	; 0x94c <xQueueReceive+0x70>
 944:	0f 90       	pop	r0
 946:	0f be       	out	0x3f, r0	; 63
 948:	80 e0       	ldi	r24, 0x00	; 0
 94a:	4d c0       	rjmp	.+154    	; 0x9e6 <xQueueReceive+0x10a>
 94c:	e1 10       	cpse	r14, r1
 94e:	06 c0       	rjmp	.+12     	; 0x95c <xQueueReceive+0x80>
 950:	ce 01       	movw	r24, r28
 952:	01 96       	adiw	r24, 0x01	; 1
 954:	0e 94 c5 10 	call	0x218a	; 0x218a <vTaskInternalSetTimeOutState>
 958:	ee 24       	eor	r14, r14
 95a:	e3 94       	inc	r14
 95c:	0f 90       	pop	r0
 95e:	0f be       	out	0x3f, r0	; 63
 960:	0e 94 fc 10 	call	0x21f8	; 0x21f8 <vTaskSuspendAll>
 964:	0f b6       	in	r0, 0x3f	; 63
 966:	f8 94       	cli
 968:	0f 92       	push	r0
 96a:	f8 01       	movw	r30, r16
 96c:	85 8d       	ldd	r24, Z+29	; 0x1d
 96e:	8f 3f       	cpi	r24, 0xFF	; 255
 970:	09 f4       	brne	.+2      	; 0x974 <xQueueReceive+0x98>
 972:	15 8e       	std	Z+29, r1	; 0x1d
 974:	f8 01       	movw	r30, r16
 976:	86 8d       	ldd	r24, Z+30	; 0x1e
 978:	8f 3f       	cpi	r24, 0xFF	; 255
 97a:	09 f4       	brne	.+2      	; 0x97e <xQueueReceive+0xa2>
 97c:	16 8e       	std	Z+30, r1	; 0x1e
 97e:	0f 90       	pop	r0
 980:	0f be       	out	0x3f, r0	; 63
 982:	be 01       	movw	r22, r28
 984:	6c 5f       	subi	r22, 0xFC	; 252
 986:	7f 4f       	sbci	r23, 0xFF	; 255
 988:	ce 01       	movw	r24, r28
 98a:	01 96       	adiw	r24, 0x01	; 1
 98c:	0e 94 c3 0b 	call	0x1786	; 0x1786 <xTaskCheckForTimeOut>
 990:	81 11       	cpse	r24, r1
 992:	1c c0       	rjmp	.+56     	; 0x9cc <xQueueReceive+0xf0>
 994:	b8 01       	movw	r22, r16
 996:	80 e8       	ldi	r24, 0x80	; 128
 998:	0e 94 59 10 	call	0x20b2	; 0x20b2 <prvIsQueueEmpty>
 99c:	88 23       	and	r24, r24
 99e:	81 f0       	breq	.+32     	; 0x9c0 <xQueueReceive+0xe4>
 9a0:	6c 81       	ldd	r22, Y+4	; 0x04
 9a2:	7d 81       	ldd	r23, Y+5	; 0x05
 9a4:	c8 01       	movw	r24, r16
 9a6:	41 96       	adiw	r24, 0x11	; 17
 9a8:	0e 94 6c 10 	call	0x20d8	; 0x20d8 <vTaskPlaceOnEventList>
 9ac:	c8 01       	movw	r24, r16
 9ae:	0e 94 3d 0b 	call	0x167a	; 0x167a <prvUnlockQueue>
 9b2:	0e 94 8d 01 	call	0x31a	; 0x31a <xTaskResumeAll>
 9b6:	81 11       	cpse	r24, r1
 9b8:	a3 cf       	rjmp	.-186    	; 0x900 <xQueueReceive+0x24>
 9ba:	0e 94 cb 08 	call	0x1196	; 0x1196 <vPortYield>
 9be:	a0 cf       	rjmp	.-192    	; 0x900 <xQueueReceive+0x24>
 9c0:	c8 01       	movw	r24, r16
 9c2:	0e 94 3d 0b 	call	0x167a	; 0x167a <prvUnlockQueue>
 9c6:	0e 94 8d 01 	call	0x31a	; 0x31a <xTaskResumeAll>
 9ca:	9a cf       	rjmp	.-204    	; 0x900 <xQueueReceive+0x24>
 9cc:	c8 01       	movw	r24, r16
 9ce:	0e 94 3d 0b 	call	0x167a	; 0x167a <prvUnlockQueue>
 9d2:	0e 94 8d 01 	call	0x31a	; 0x31a <xTaskResumeAll>
 9d6:	b8 01       	movw	r22, r16
 9d8:	80 e8       	ldi	r24, 0x80	; 128
 9da:	0e 94 59 10 	call	0x20b2	; 0x20b2 <prvIsQueueEmpty>
 9de:	88 23       	and	r24, r24
 9e0:	09 f4       	brne	.+2      	; 0x9e4 <xQueueReceive+0x108>
 9e2:	8e cf       	rjmp	.-228    	; 0x900 <xQueueReceive+0x24>
 9e4:	80 e0       	ldi	r24, 0x00	; 0
 9e6:	0f 90       	pop	r0
 9e8:	0f 90       	pop	r0
 9ea:	0f 90       	pop	r0
 9ec:	0f 90       	pop	r0
 9ee:	0f 90       	pop	r0
 9f0:	df 91       	pop	r29
 9f2:	cf 91       	pop	r28
 9f4:	1f 91       	pop	r17
 9f6:	0f 91       	pop	r16
 9f8:	ff 90       	pop	r15
 9fa:	ef 90       	pop	r14
 9fc:	df 90       	pop	r13
 9fe:	cf 90       	pop	r12
 a00:	08 95       	ret

Disassembly of section .text.vQueueWaitForMessageRestricted:

00001f1c <vQueueWaitForMessageRestricted>:
#if ( configUSE_TIMERS == 1 )

    void vQueueWaitForMessageRestricted( QueueHandle_t xQueue,
                                         TickType_t xTicksToWait,
                                         const BaseType_t xWaitIndefinitely )
    {
    1f1c:	cf 93       	push	r28
    1f1e:	df 93       	push	r29
    1f20:	ec 01       	movw	r28, r24
         *  will not actually cause the task to block, just place it on a blocked
         *  list.  It will not block until the scheduler is unlocked - at which
         *  time a yield will be performed.  If an item is added to the queue while
         *  the queue is locked, and the calling task blocks on the queue, then the
         *  calling task will be immediately unblocked when the queue is unlocked. */
        prvLockQueue( pxQueue );
    1f22:	0f b6       	in	r0, 0x3f	; 63
    1f24:	f8 94       	cli
    1f26:	0f 92       	push	r0
    1f28:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1f2a:	8f 3f       	cpi	r24, 0xFF	; 255
    1f2c:	09 f4       	brne	.+2      	; 0x1f30 <vQueueWaitForMessageRestricted+0x14>
    1f2e:	1d 8e       	std	Y+29, r1	; 0x1d
    1f30:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1f32:	8f 3f       	cpi	r24, 0xFF	; 255
    1f34:	09 f4       	brne	.+2      	; 0x1f38 <vQueueWaitForMessageRestricted+0x1c>
    1f36:	1e 8e       	std	Y+30, r1	; 0x1e
    1f38:	0f 90       	pop	r0
    1f3a:	0f be       	out	0x3f, r0	; 63

        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
    1f3c:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1f3e:	81 11       	cpse	r24, r1
    1f40:	04 c0       	rjmp	.+8      	; 0x1f4a <vQueueWaitForMessageRestricted+0x2e>
        {
            /* There is nothing in the queue, block for the specified period. */
            vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
    1f42:	ce 01       	movw	r24, r28
    1f44:	41 96       	adiw	r24, 0x11	; 17
    1f46:	0e 94 ac 0a 	call	0x1558	; 0x1558 <vTaskPlaceOnEventListRestricted>
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        prvUnlockQueue( pxQueue );
    1f4a:	ce 01       	movw	r24, r28
    1f4c:	0e 94 3d 0b 	call	0x167a	; 0x167a <prvUnlockQueue>
    }
    1f50:	df 91       	pop	r29
    1f52:	cf 91       	pop	r28
    1f54:	08 95       	ret

Disassembly of section .text.prvResetNextTaskUnblockTime:

00001f8e <prvResetNextTaskUnblockTime>:
        xReturn = xTickCount;
    }
    portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
}
    1f8e:	e0 91 b3 06 	lds	r30, 0x06B3	; 0x8006b3 <pxDelayedTaskList>
    1f92:	f0 91 b4 06 	lds	r31, 0x06B4	; 0x8006b4 <pxDelayedTaskList+0x1>
    1f96:	80 81       	ld	r24, Z
    1f98:	81 11       	cpse	r24, r1
    1f9a:	07 c0       	rjmp	.+14     	; 0x1faa <prvResetNextTaskUnblockTime+0x1c>
    1f9c:	8f ef       	ldi	r24, 0xFF	; 255
    1f9e:	9f ef       	ldi	r25, 0xFF	; 255
    1fa0:	90 93 ac 06 	sts	0x06AC, r25	; 0x8006ac <xNextTaskUnblockTime+0x1>
    1fa4:	80 93 ab 06 	sts	0x06AB, r24	; 0x8006ab <xNextTaskUnblockTime>
    1fa8:	08 95       	ret
    1faa:	e0 91 b3 06 	lds	r30, 0x06B3	; 0x8006b3 <pxDelayedTaskList>
    1fae:	f0 91 b4 06 	lds	r31, 0x06B4	; 0x8006b4 <pxDelayedTaskList+0x1>
    1fb2:	05 80       	ldd	r0, Z+5	; 0x05
    1fb4:	f6 81       	ldd	r31, Z+6	; 0x06
    1fb6:	e0 2d       	mov	r30, r0
    1fb8:	80 81       	ld	r24, Z
    1fba:	91 81       	ldd	r25, Z+1	; 0x01
    1fbc:	90 93 ac 06 	sts	0x06AC, r25	; 0x8006ac <xNextTaskUnblockTime+0x1>
    1fc0:	80 93 ab 06 	sts	0x06AB, r24	; 0x8006ab <xNextTaskUnblockTime>
    1fc4:	08 95       	ret

Disassembly of section .text.prvDeleteTCB:

00002170 <prvDeleteTCB>:
    2170:	cf 93       	push	r28
    2172:	df 93       	push	r29
    2174:	ec 01       	movw	r28, r24
    2176:	8f 89       	ldd	r24, Y+23	; 0x17
    2178:	98 8d       	ldd	r25, Y+24	; 0x18
    217a:	0e 94 22 11 	call	0x2244	; 0x2244 <vPortFree>
    217e:	ce 01       	movw	r24, r28
    2180:	0e 94 22 11 	call	0x2244	; 0x2244 <vPortFree>
    2184:	df 91       	pop	r29
    2186:	cf 91       	pop	r28
    2188:	08 95       	ret

Disassembly of section .text.prvInitialiseNewTask:

00000bfe <prvInitialiseNewTask>:
 bfe:	6f 92       	push	r6
 c00:	7f 92       	push	r7
 c02:	8f 92       	push	r8
 c04:	9f 92       	push	r9
 c06:	af 92       	push	r10
 c08:	bf 92       	push	r11
 c0a:	cf 92       	push	r12
 c0c:	df 92       	push	r13
 c0e:	ef 92       	push	r14
 c10:	ff 92       	push	r15
 c12:	0f 93       	push	r16
 c14:	1f 93       	push	r17
 c16:	cf 93       	push	r28
 c18:	df 93       	push	r29
 c1a:	cd b7       	in	r28, 0x3d	; 61
 c1c:	de b7       	in	r29, 0x3e	; 62
 c1e:	3c 01       	movw	r6, r24
 c20:	a6 2f       	mov	r26, r22
 c22:	ca 01       	movw	r24, r20
 c24:	f4 01       	movw	r30, r8
 c26:	47 89       	ldd	r20, Z+23	; 0x17
 c28:	50 8d       	ldd	r21, Z+24	; 0x18
 c2a:	01 50       	subi	r16, 0x01	; 1
 c2c:	11 09       	sbc	r17, r1
 c2e:	04 0f       	add	r16, r20
 c30:	15 1f       	adc	r17, r21
 c32:	00 97       	sbiw	r24, 0x00	; 0
 c34:	a1 05       	cpc	r26, r1
 c36:	d1 f4       	brne	.+52     	; 0xc6c <prvInitialiseNewTask+0x6e>
 c38:	1e c0       	rjmp	.+60     	; 0xc76 <prvInitialiseNewTask+0x78>
 c3a:	27 2f       	mov	r18, r23
 c3c:	30 e0       	ldi	r19, 0x00	; 0
 c3e:	ac 01       	movw	r20, r24
 c40:	6a 2f       	mov	r22, r26
 c42:	42 0f       	add	r20, r18
 c44:	53 1f       	adc	r21, r19
 c46:	61 1d       	adc	r22, r1
 c48:	37 fd       	sbrc	r19, 7
 c4a:	6a 95       	dec	r22
 c4c:	fa 01       	movw	r30, r20
 c4e:	b4 91       	lpm	r27, Z
 c50:	67 fd       	sbrc	r22, 7
 c52:	b0 81       	ld	r27, Z
 c54:	f4 01       	movw	r30, r8
 c56:	e2 0f       	add	r30, r18
 c58:	f3 1f       	adc	r31, r19
 c5a:	b1 8f       	std	Z+25, r27	; 0x19
 c5c:	fa 01       	movw	r30, r20
 c5e:	24 91       	lpm	r18, Z
 c60:	67 fd       	sbrc	r22, 7
 c62:	20 81       	ld	r18, Z
 c64:	22 23       	and	r18, r18
 c66:	29 f0       	breq	.+10     	; 0xc72 <prvInitialiseNewTask+0x74>
 c68:	7f 5f       	subi	r23, 0xFF	; 255
 c6a:	01 c0       	rjmp	.+2      	; 0xc6e <prvInitialiseNewTask+0x70>
 c6c:	70 e0       	ldi	r23, 0x00	; 0
 c6e:	78 30       	cpi	r23, 0x08	; 8
 c70:	20 f3       	brcs	.-56     	; 0xc3a <prvInitialiseNewTask+0x3c>
 c72:	f4 01       	movw	r30, r8
 c74:	10 a2       	std	Z+32, r1	; 0x20
 c76:	f3 e0       	ldi	r31, 0x03	; 3
 c78:	fc 15       	cp	r31, r12
 c7a:	20 f4       	brcc	.+8      	; 0xc84 <prvInitialiseNewTask+0x86>
 c7c:	0f 2e       	mov	r0, r31
 c7e:	f3 e0       	ldi	r31, 0x03	; 3
 c80:	cf 2e       	mov	r12, r31
 c82:	f0 2d       	mov	r31, r0
 c84:	f4 01       	movw	r30, r8
 c86:	c6 8a       	std	Z+22, r12	; 0x16
 c88:	c4 01       	movw	r24, r8
 c8a:	02 96       	adiw	r24, 0x02	; 2
 c8c:	0e 94 0d 11 	call	0x221a	; 0x221a <vListInitialiseItem>
 c90:	c4 01       	movw	r24, r8
 c92:	0c 96       	adiw	r24, 0x0c	; 12
 c94:	0e 94 0d 11 	call	0x221a	; 0x221a <vListInitialiseItem>
 c98:	f4 01       	movw	r30, r8
 c9a:	91 86       	std	Z+9, r9	; 0x09
 c9c:	80 86       	std	Z+8, r8	; 0x08
 c9e:	84 e0       	ldi	r24, 0x04	; 4
 ca0:	90 e0       	ldi	r25, 0x00	; 0
 ca2:	8c 19       	sub	r24, r12
 ca4:	91 09       	sbc	r25, r1
 ca6:	95 87       	std	Z+13, r25	; 0x0d
 ca8:	84 87       	std	Z+12, r24	; 0x0c
 caa:	93 8a       	std	Z+19, r9	; 0x13
 cac:	82 8a       	std	Z+18, r8	; 0x12
 cae:	a7 01       	movw	r20, r14
 cb0:	b3 01       	movw	r22, r6
 cb2:	c8 01       	movw	r24, r16
 cb4:	0e 94 e3 06 	call	0xdc6	; 0xdc6 <pxPortInitialiseStack>
 cb8:	f4 01       	movw	r30, r8
 cba:	91 83       	std	Z+1, r25	; 0x01
 cbc:	80 83       	st	Z, r24
 cbe:	a1 14       	cp	r10, r1
 cc0:	b1 04       	cpc	r11, r1
 cc2:	19 f0       	breq	.+6      	; 0xcca <prvInitialiseNewTask+0xcc>
 cc4:	f5 01       	movw	r30, r10
 cc6:	91 82       	std	Z+1, r9	; 0x01
 cc8:	80 82       	st	Z, r8
 cca:	df 91       	pop	r29
 ccc:	cf 91       	pop	r28
 cce:	1f 91       	pop	r17
 cd0:	0f 91       	pop	r16
 cd2:	ff 90       	pop	r15
 cd4:	ef 90       	pop	r14
 cd6:	df 90       	pop	r13
 cd8:	cf 90       	pop	r12
 cda:	bf 90       	pop	r11
 cdc:	af 90       	pop	r10
 cde:	9f 90       	pop	r9
 ce0:	8f 90       	pop	r8
 ce2:	7f 90       	pop	r7
 ce4:	6f 90       	pop	r6
 ce6:	08 95       	ret

Disassembly of section .text.prvInitialiseTaskLists:

000018ee <prvInitialiseTaskLists>:
    18ee:	cf 93       	push	r28
    18f0:	c0 e0       	ldi	r28, 0x00	; 0
    18f2:	10 c0       	rjmp	.+32     	; 0x1914 <prvInitialiseTaskLists+0x26>
    18f4:	8c 2f       	mov	r24, r28
    18f6:	90 e0       	ldi	r25, 0x00	; 0
    18f8:	9c 01       	movw	r18, r24
    18fa:	22 0f       	add	r18, r18
    18fc:	33 1f       	adc	r19, r19
    18fe:	22 0f       	add	r18, r18
    1900:	33 1f       	adc	r19, r19
    1902:	22 0f       	add	r18, r18
    1904:	33 1f       	adc	r19, r19
    1906:	82 0f       	add	r24, r18
    1908:	93 1f       	adc	r25, r19
    190a:	8e 5b       	subi	r24, 0xBE	; 190
    190c:	99 4f       	sbci	r25, 0xF9	; 249
    190e:	0e 94 9c 10 	call	0x2138	; 0x2138 <vListInitialise>
    1912:	cf 5f       	subi	r28, 0xFF	; 255
    1914:	c4 30       	cpi	r28, 0x04	; 4
    1916:	70 f3       	brcs	.-36     	; 0x18f4 <prvInitialiseTaskLists+0x6>
    1918:	8a e8       	ldi	r24, 0x8A	; 138
    191a:	96 e0       	ldi	r25, 0x06	; 6
    191c:	0e 94 9c 10 	call	0x2138	; 0x2138 <vListInitialise>
    1920:	81 e8       	ldi	r24, 0x81	; 129
    1922:	96 e0       	ldi	r25, 0x06	; 6
    1924:	0e 94 9c 10 	call	0x2138	; 0x2138 <vListInitialise>
    1928:	88 e7       	ldi	r24, 0x78	; 120
    192a:	96 e0       	ldi	r25, 0x06	; 6
    192c:	0e 94 9c 10 	call	0x2138	; 0x2138 <vListInitialise>
    1930:	8f e6       	ldi	r24, 0x6F	; 111
    1932:	96 e0       	ldi	r25, 0x06	; 6
    1934:	0e 94 9c 10 	call	0x2138	; 0x2138 <vListInitialise>
    1938:	86 e6       	ldi	r24, 0x66	; 102
    193a:	96 e0       	ldi	r25, 0x06	; 6
    193c:	0e 94 9c 10 	call	0x2138	; 0x2138 <vListInitialise>
    1940:	8a e8       	ldi	r24, 0x8A	; 138
    1942:	96 e0       	ldi	r25, 0x06	; 6
    1944:	90 93 b4 06 	sts	0x06B4, r25	; 0x8006b4 <pxDelayedTaskList+0x1>
    1948:	80 93 b3 06 	sts	0x06B3, r24	; 0x8006b3 <pxDelayedTaskList>
    194c:	81 e8       	ldi	r24, 0x81	; 129
    194e:	96 e0       	ldi	r25, 0x06	; 6
    1950:	90 93 b2 06 	sts	0x06B2, r25	; 0x8006b2 <pxOverflowDelayedTaskList+0x1>
    1954:	80 93 b1 06 	sts	0x06B1, r24	; 0x8006b1 <pxOverflowDelayedTaskList>
    1958:	cf 91       	pop	r28
    195a:	08 95       	ret

Disassembly of section .text.prvAddNewTaskToReadyList:

00000b04 <prvAddNewTaskToReadyList>:
 b04:	cf 93       	push	r28
 b06:	df 93       	push	r29
 b08:	ec 01       	movw	r28, r24
 b0a:	0f b6       	in	r0, 0x3f	; 63
 b0c:	f8 94       	cli
 b0e:	0f 92       	push	r0
 b10:	80 91 c7 06 	lds	r24, 0x06C7	; 0x8006c7 <uxCurrentNumberOfTasks>
 b14:	8f 5f       	subi	r24, 0xFF	; 255
 b16:	80 93 c7 06 	sts	0x06C7, r24	; 0x8006c7 <uxCurrentNumberOfTasks>
 b1a:	80 91 b5 06 	lds	r24, 0x06B5	; 0x8006b5 <pxCurrentTCB>
 b1e:	90 91 b6 06 	lds	r25, 0x06B6	; 0x8006b6 <pxCurrentTCB+0x1>
 b22:	89 2b       	or	r24, r25
 b24:	59 f4       	brne	.+22     	; 0xb3c <prvAddNewTaskToReadyList+0x38>
 b26:	d0 93 b6 06 	sts	0x06B6, r29	; 0x8006b6 <pxCurrentTCB+0x1>
 b2a:	c0 93 b5 06 	sts	0x06B5, r28	; 0x8006b5 <pxCurrentTCB>
 b2e:	80 91 c7 06 	lds	r24, 0x06C7	; 0x8006c7 <uxCurrentNumberOfTasks>
 b32:	81 30       	cpi	r24, 0x01	; 1
 b34:	99 f4       	brne	.+38     	; 0xb5c <prvAddNewTaskToReadyList+0x58>
 b36:	0e 94 77 0c 	call	0x18ee	; 0x18ee <prvInitialiseTaskLists>
 b3a:	10 c0       	rjmp	.+32     	; 0xb5c <prvAddNewTaskToReadyList+0x58>
 b3c:	80 91 c5 06 	lds	r24, 0x06C5	; 0x8006c5 <xSchedulerRunning>
 b40:	81 11       	cpse	r24, r1
 b42:	0c c0       	rjmp	.+24     	; 0xb5c <prvAddNewTaskToReadyList+0x58>
 b44:	e0 91 b5 06 	lds	r30, 0x06B5	; 0x8006b5 <pxCurrentTCB>
 b48:	f0 91 b6 06 	lds	r31, 0x06B6	; 0x8006b6 <pxCurrentTCB+0x1>
 b4c:	96 89       	ldd	r25, Z+22	; 0x16
 b4e:	8e 89       	ldd	r24, Y+22	; 0x16
 b50:	89 17       	cp	r24, r25
 b52:	20 f0       	brcs	.+8      	; 0xb5c <prvAddNewTaskToReadyList+0x58>
 b54:	d0 93 b6 06 	sts	0x06B6, r29	; 0x8006b6 <pxCurrentTCB+0x1>
 b58:	c0 93 b5 06 	sts	0x06B5, r28	; 0x8006b5 <pxCurrentTCB>
 b5c:	80 91 c2 06 	lds	r24, 0x06C2	; 0x8006c2 <uxTaskNumber>
 b60:	8f 5f       	subi	r24, 0xFF	; 255
 b62:	80 93 c2 06 	sts	0x06C2, r24	; 0x8006c2 <uxTaskNumber>
 b66:	8e 89       	ldd	r24, Y+22	; 0x16
 b68:	90 91 c6 06 	lds	r25, 0x06C6	; 0x8006c6 <uxTopReadyPriority>
 b6c:	98 17       	cp	r25, r24
 b6e:	10 f4       	brcc	.+4      	; 0xb74 <prvAddNewTaskToReadyList+0x70>
 b70:	80 93 c6 06 	sts	0x06C6, r24	; 0x8006c6 <uxTopReadyPriority>
 b74:	90 e0       	ldi	r25, 0x00	; 0
 b76:	fc 01       	movw	r30, r24
 b78:	ee 0f       	add	r30, r30
 b7a:	ff 1f       	adc	r31, r31
 b7c:	ee 0f       	add	r30, r30
 b7e:	ff 1f       	adc	r31, r31
 b80:	ee 0f       	add	r30, r30
 b82:	ff 1f       	adc	r31, r31
 b84:	8e 0f       	add	r24, r30
 b86:	9f 1f       	adc	r25, r31
 b88:	fc 01       	movw	r30, r24
 b8a:	ee 5b       	subi	r30, 0xBE	; 190
 b8c:	f9 4f       	sbci	r31, 0xF9	; 249
 b8e:	01 80       	ldd	r0, Z+1	; 0x01
 b90:	f2 81       	ldd	r31, Z+2	; 0x02
 b92:	e0 2d       	mov	r30, r0
 b94:	fd 83       	std	Y+5, r31	; 0x05
 b96:	ec 83       	std	Y+4, r30	; 0x04
 b98:	84 81       	ldd	r24, Z+4	; 0x04
 b9a:	95 81       	ldd	r25, Z+5	; 0x05
 b9c:	9f 83       	std	Y+7, r25	; 0x07
 b9e:	8e 83       	std	Y+6, r24	; 0x06
 ba0:	a4 81       	ldd	r26, Z+4	; 0x04
 ba2:	b5 81       	ldd	r27, Z+5	; 0x05
 ba4:	ce 01       	movw	r24, r28
 ba6:	02 96       	adiw	r24, 0x02	; 2
 ba8:	13 96       	adiw	r26, 0x03	; 3
 baa:	9c 93       	st	X, r25
 bac:	8e 93       	st	-X, r24
 bae:	12 97       	sbiw	r26, 0x02	; 2
 bb0:	95 83       	std	Z+5, r25	; 0x05
 bb2:	84 83       	std	Z+4, r24	; 0x04
 bb4:	ee 89       	ldd	r30, Y+22	; 0x16
 bb6:	f0 e0       	ldi	r31, 0x00	; 0
 bb8:	cf 01       	movw	r24, r30
 bba:	88 0f       	add	r24, r24
 bbc:	99 1f       	adc	r25, r25
 bbe:	88 0f       	add	r24, r24
 bc0:	99 1f       	adc	r25, r25
 bc2:	88 0f       	add	r24, r24
 bc4:	99 1f       	adc	r25, r25
 bc6:	e8 0f       	add	r30, r24
 bc8:	f9 1f       	adc	r31, r25
 bca:	ee 5b       	subi	r30, 0xBE	; 190
 bcc:	f9 4f       	sbci	r31, 0xF9	; 249
 bce:	fb 87       	std	Y+11, r31	; 0x0b
 bd0:	ea 87       	std	Y+10, r30	; 0x0a
 bd2:	80 81       	ld	r24, Z
 bd4:	8f 5f       	subi	r24, 0xFF	; 255
 bd6:	80 83       	st	Z, r24
 bd8:	0f 90       	pop	r0
 bda:	0f be       	out	0x3f, r0	; 63
 bdc:	80 91 c5 06 	lds	r24, 0x06C5	; 0x8006c5 <xSchedulerRunning>
 be0:	88 23       	and	r24, r24
 be2:	51 f0       	breq	.+20     	; 0xbf8 <prvAddNewTaskToReadyList+0xf4>
 be4:	e0 91 b5 06 	lds	r30, 0x06B5	; 0x8006b5 <pxCurrentTCB>
 be8:	f0 91 b6 06 	lds	r31, 0x06B6	; 0x8006b6 <pxCurrentTCB+0x1>
 bec:	96 89       	ldd	r25, Z+22	; 0x16
 bee:	8e 89       	ldd	r24, Y+22	; 0x16
 bf0:	98 17       	cp	r25, r24
 bf2:	10 f4       	brcc	.+4      	; 0xbf8 <prvAddNewTaskToReadyList+0xf4>
 bf4:	0e 94 cb 08 	call	0x1196	; 0x1196 <vPortYield>
 bf8:	df 91       	pop	r29
 bfa:	cf 91       	pop	r28
 bfc:	08 95       	ret

Disassembly of section .text.prvCheckTasksWaitingTermination:

00001dc8 <prvCheckTasksWaitingTermination>:
    1dc8:	cf 93       	push	r28
    1dca:	df 93       	push	r29
    1dcc:	1c c0       	rjmp	.+56     	; 0x1e06 <prvCheckTasksWaitingTermination+0x3e>
    1dce:	0f b6       	in	r0, 0x3f	; 63
    1dd0:	f8 94       	cli
    1dd2:	0f 92       	push	r0
    1dd4:	e0 91 74 06 	lds	r30, 0x0674	; 0x800674 <xTasksWaitingTermination+0x5>
    1dd8:	f0 91 75 06 	lds	r31, 0x0675	; 0x800675 <xTasksWaitingTermination+0x6>
    1ddc:	c6 81       	ldd	r28, Z+6	; 0x06
    1dde:	d7 81       	ldd	r29, Z+7	; 0x07
    1de0:	ce 01       	movw	r24, r28
    1de2:	02 96       	adiw	r24, 0x02	; 2
    1de4:	0e 94 bd 0e 	call	0x1d7a	; 0x1d7a <uxListRemove>
    1de8:	80 91 c7 06 	lds	r24, 0x06C7	; 0x8006c7 <uxCurrentNumberOfTasks>
    1dec:	81 50       	subi	r24, 0x01	; 1
    1dee:	80 93 c7 06 	sts	0x06C7, r24	; 0x8006c7 <uxCurrentNumberOfTasks>
    1df2:	80 91 c8 06 	lds	r24, 0x06C8	; 0x8006c8 <uxDeletedTasksWaitingCleanUp>
    1df6:	81 50       	subi	r24, 0x01	; 1
    1df8:	80 93 c8 06 	sts	0x06C8, r24	; 0x8006c8 <uxDeletedTasksWaitingCleanUp>
    1dfc:	0f 90       	pop	r0
    1dfe:	0f be       	out	0x3f, r0	; 63
    1e00:	ce 01       	movw	r24, r28
    1e02:	0e 94 b8 10 	call	0x2170	; 0x2170 <prvDeleteTCB>
    1e06:	80 91 c8 06 	lds	r24, 0x06C8	; 0x8006c8 <uxDeletedTasksWaitingCleanUp>
    1e0a:	81 11       	cpse	r24, r1
    1e0c:	e0 cf       	rjmp	.-64     	; 0x1dce <prvCheckTasksWaitingTermination+0x6>
    1e0e:	df 91       	pop	r29
    1e10:	cf 91       	pop	r28
    1e12:	08 95       	ret

Disassembly of section .text.prvIdleTask:

00002230 <prvIdleTask>:
    2230:	0e 94 e4 0e 	call	0x1dc8	; 0x1dc8 <prvCheckTasksWaitingTermination>
    2234:	fd cf       	rjmp	.-6      	; 0x2230 <prvIdleTask>

Disassembly of section .text.prvAddCurrentTaskToDelayedList:

00000a02 <prvAddCurrentTaskToDelayedList>:
 a02:	ff 92       	push	r15
 a04:	0f 93       	push	r16
 a06:	1f 93       	push	r17
 a08:	cf 93       	push	r28
 a0a:	df 93       	push	r29
 a0c:	ec 01       	movw	r28, r24
 a0e:	f6 2e       	mov	r15, r22
 a10:	00 91 af 06 	lds	r16, 0x06AF	; 0x8006af <xTickCount>
 a14:	10 91 b0 06 	lds	r17, 0x06B0	; 0x8006b0 <xTickCount+0x1>
 a18:	80 91 b5 06 	lds	r24, 0x06B5	; 0x8006b5 <pxCurrentTCB>
 a1c:	90 91 b6 06 	lds	r25, 0x06B6	; 0x8006b6 <pxCurrentTCB+0x1>
 a20:	02 96       	adiw	r24, 0x02	; 2
 a22:	0e 94 bd 0e 	call	0x1d7a	; 0x1d7a <uxListRemove>
 a26:	cf 3f       	cpi	r28, 0xFF	; 255
 a28:	8f ef       	ldi	r24, 0xFF	; 255
 a2a:	d8 07       	cpc	r29, r24
 a2c:	b1 f5       	brne	.+108    	; 0xa9a <prvAddCurrentTaskToDelayedList+0x98>
 a2e:	ff 20       	and	r15, r15
 a30:	a1 f1       	breq	.+104    	; 0xa9a <prvAddCurrentTaskToDelayedList+0x98>
 a32:	e6 e6       	ldi	r30, 0x66	; 102
 a34:	f6 e0       	ldi	r31, 0x06	; 6
 a36:	a1 81       	ldd	r26, Z+1	; 0x01
 a38:	b2 81       	ldd	r27, Z+2	; 0x02
 a3a:	c0 91 b5 06 	lds	r28, 0x06B5	; 0x8006b5 <pxCurrentTCB>
 a3e:	d0 91 b6 06 	lds	r29, 0x06B6	; 0x8006b6 <pxCurrentTCB+0x1>
 a42:	bd 83       	std	Y+5, r27	; 0x05
 a44:	ac 83       	std	Y+4, r26	; 0x04
 a46:	c0 91 b5 06 	lds	r28, 0x06B5	; 0x8006b5 <pxCurrentTCB>
 a4a:	d0 91 b6 06 	lds	r29, 0x06B6	; 0x8006b6 <pxCurrentTCB+0x1>
 a4e:	14 96       	adiw	r26, 0x04	; 4
 a50:	8d 91       	ld	r24, X+
 a52:	9c 91       	ld	r25, X
 a54:	15 97       	sbiw	r26, 0x05	; 5
 a56:	9f 83       	std	Y+7, r25	; 0x07
 a58:	8e 83       	std	Y+6, r24	; 0x06
 a5a:	14 96       	adiw	r26, 0x04	; 4
 a5c:	cd 91       	ld	r28, X+
 a5e:	dc 91       	ld	r29, X
 a60:	15 97       	sbiw	r26, 0x05	; 5
 a62:	80 91 b5 06 	lds	r24, 0x06B5	; 0x8006b5 <pxCurrentTCB>
 a66:	90 91 b6 06 	lds	r25, 0x06B6	; 0x8006b6 <pxCurrentTCB+0x1>
 a6a:	02 96       	adiw	r24, 0x02	; 2
 a6c:	9b 83       	std	Y+3, r25	; 0x03
 a6e:	8a 83       	std	Y+2, r24	; 0x02
 a70:	80 91 b5 06 	lds	r24, 0x06B5	; 0x8006b5 <pxCurrentTCB>
 a74:	90 91 b6 06 	lds	r25, 0x06B6	; 0x8006b6 <pxCurrentTCB+0x1>
 a78:	02 96       	adiw	r24, 0x02	; 2
 a7a:	15 96       	adiw	r26, 0x05	; 5
 a7c:	9c 93       	st	X, r25
 a7e:	8e 93       	st	-X, r24
 a80:	14 97       	sbiw	r26, 0x04	; 4
 a82:	a0 91 b5 06 	lds	r26, 0x06B5	; 0x8006b5 <pxCurrentTCB>
 a86:	b0 91 b6 06 	lds	r27, 0x06B6	; 0x8006b6 <pxCurrentTCB+0x1>
 a8a:	1b 96       	adiw	r26, 0x0b	; 11
 a8c:	fc 93       	st	X, r31
 a8e:	ee 93       	st	-X, r30
 a90:	1a 97       	sbiw	r26, 0x0a	; 10
 a92:	80 81       	ld	r24, Z
 a94:	8f 5f       	subi	r24, 0xFF	; 255
 a96:	80 83       	st	Z, r24
 a98:	2f c0       	rjmp	.+94     	; 0xaf8 <prvAddCurrentTaskToDelayedList+0xf6>
 a9a:	c0 0f       	add	r28, r16
 a9c:	d1 1f       	adc	r29, r17
 a9e:	e0 91 b5 06 	lds	r30, 0x06B5	; 0x8006b5 <pxCurrentTCB>
 aa2:	f0 91 b6 06 	lds	r31, 0x06B6	; 0x8006b6 <pxCurrentTCB+0x1>
 aa6:	d3 83       	std	Z+3, r29	; 0x03
 aa8:	c2 83       	std	Z+2, r28	; 0x02
 aaa:	c0 17       	cp	r28, r16
 aac:	d1 07       	cpc	r29, r17
 aae:	68 f4       	brcc	.+26     	; 0xaca <prvAddCurrentTaskToDelayedList+0xc8>
 ab0:	60 91 b5 06 	lds	r22, 0x06B5	; 0x8006b5 <pxCurrentTCB>
 ab4:	70 91 b6 06 	lds	r23, 0x06B6	; 0x8006b6 <pxCurrentTCB+0x1>
 ab8:	80 91 b1 06 	lds	r24, 0x06B1	; 0x8006b1 <pxOverflowDelayedTaskList>
 abc:	90 91 b2 06 	lds	r25, 0x06B2	; 0x8006b2 <pxOverflowDelayedTaskList+0x1>
 ac0:	6e 5f       	subi	r22, 0xFE	; 254
 ac2:	7f 4f       	sbci	r23, 0xFF	; 255
 ac4:	0e 94 7f 0d 	call	0x1afe	; 0x1afe <vListInsert>
 ac8:	17 c0       	rjmp	.+46     	; 0xaf8 <prvAddCurrentTaskToDelayedList+0xf6>
 aca:	60 91 b5 06 	lds	r22, 0x06B5	; 0x8006b5 <pxCurrentTCB>
 ace:	70 91 b6 06 	lds	r23, 0x06B6	; 0x8006b6 <pxCurrentTCB+0x1>
 ad2:	80 91 b3 06 	lds	r24, 0x06B3	; 0x8006b3 <pxDelayedTaskList>
 ad6:	90 91 b4 06 	lds	r25, 0x06B4	; 0x8006b4 <pxDelayedTaskList+0x1>
 ada:	6e 5f       	subi	r22, 0xFE	; 254
 adc:	7f 4f       	sbci	r23, 0xFF	; 255
 ade:	0e 94 7f 0d 	call	0x1afe	; 0x1afe <vListInsert>
 ae2:	80 91 ab 06 	lds	r24, 0x06AB	; 0x8006ab <xNextTaskUnblockTime>
 ae6:	90 91 ac 06 	lds	r25, 0x06AC	; 0x8006ac <xNextTaskUnblockTime+0x1>
 aea:	c8 17       	cp	r28, r24
 aec:	d9 07       	cpc	r29, r25
 aee:	20 f4       	brcc	.+8      	; 0xaf8 <prvAddCurrentTaskToDelayedList+0xf6>
 af0:	d0 93 ac 06 	sts	0x06AC, r29	; 0x8006ac <xNextTaskUnblockTime+0x1>
 af4:	c0 93 ab 06 	sts	0x06AB, r28	; 0x8006ab <xNextTaskUnblockTime>
 af8:	df 91       	pop	r29
 afa:	cf 91       	pop	r28
 afc:	1f 91       	pop	r17
 afe:	0f 91       	pop	r16
 b00:	ff 90       	pop	r15
 b02:	08 95       	ret

Disassembly of section .text.xTaskCreate:

00000ce8 <xTaskCreate>:
 ce8:	4f 92       	push	r4
 cea:	5f 92       	push	r5
 cec:	6f 92       	push	r6
 cee:	7f 92       	push	r7
 cf0:	8f 92       	push	r8
 cf2:	9f 92       	push	r9
 cf4:	af 92       	push	r10
 cf6:	bf 92       	push	r11
 cf8:	cf 92       	push	r12
 cfa:	df 92       	push	r13
 cfc:	ef 92       	push	r14
 cfe:	ff 92       	push	r15
 d00:	0f 93       	push	r16
 d02:	1f 93       	push	r17
 d04:	cf 93       	push	r28
 d06:	df 93       	push	r29
 d08:	00 d0       	rcall	.+0      	; 0xd0a <xTaskCreate+0x22>
 d0a:	00 d0       	rcall	.+0      	; 0xd0c <xTaskCreate+0x24>
 d0c:	0f 92       	push	r0
 d0e:	cd b7       	in	r28, 0x3d	; 61
 d10:	de b7       	in	r29, 0x3e	; 62
 d12:	3c 01       	movw	r6, r24
 d14:	49 83       	std	Y+1, r20	; 0x01
 d16:	5a 83       	std	Y+2, r21	; 0x02
 d18:	6b 83       	std	Y+3, r22	; 0x03
 d1a:	49 01       	movw	r8, r18
 d1c:	28 01       	movw	r4, r16
 d1e:	c9 01       	movw	r24, r18
 d20:	0e 94 3d 0c 	call	0x187a	; 0x187a <pvPortMalloc>
 d24:	8c 01       	movw	r16, r24
 d26:	89 2b       	or	r24, r25
 d28:	b9 f0       	breq	.+46     	; 0xd58 <xTaskCreate+0x70>
 d2a:	86 e2       	ldi	r24, 0x26	; 38
 d2c:	90 e0       	ldi	r25, 0x00	; 0
 d2e:	0e 94 3d 0c 	call	0x187a	; 0x187a <pvPortMalloc>
 d32:	9d 83       	std	Y+5, r25	; 0x05
 d34:	8c 83       	std	Y+4, r24	; 0x04
 d36:	89 2b       	or	r24, r25
 d38:	59 f0       	breq	.+22     	; 0xd50 <xTaskCreate+0x68>
 d3a:	86 e2       	ldi	r24, 0x26	; 38
 d3c:	ec 81       	ldd	r30, Y+4	; 0x04
 d3e:	fd 81       	ldd	r31, Y+5	; 0x05
 d40:	11 92       	st	Z+, r1
 d42:	8a 95       	dec	r24
 d44:	e9 f7       	brne	.-6      	; 0xd40 <xTaskCreate+0x58>
 d46:	ec 81       	ldd	r30, Y+4	; 0x04
 d48:	fd 81       	ldd	r31, Y+5	; 0x05
 d4a:	10 8f       	std	Z+24, r17	; 0x18
 d4c:	07 8b       	std	Z+23, r16	; 0x17
 d4e:	06 c0       	rjmp	.+12     	; 0xd5c <xTaskCreate+0x74>
 d50:	c8 01       	movw	r24, r16
 d52:	0e 94 22 11 	call	0x2244	; 0x2244 <vPortFree>
 d56:	02 c0       	rjmp	.+4      	; 0xd5c <xTaskCreate+0x74>
 d58:	1d 82       	std	Y+5, r1	; 0x05
 d5a:	1c 82       	std	Y+4, r1	; 0x04
 d5c:	8c 81       	ldd	r24, Y+4	; 0x04
 d5e:	9d 81       	ldd	r25, Y+5	; 0x05
 d60:	89 2b       	or	r24, r25
 d62:	d1 f0       	breq	.+52     	; 0xd98 <xTaskCreate+0xb0>
 d64:	84 01       	movw	r16, r8
 d66:	20 e0       	ldi	r18, 0x00	; 0
 d68:	30 e0       	ldi	r19, 0x00	; 0
 d6a:	1f 92       	push	r1
 d6c:	1f 92       	push	r1
 d6e:	1f 92       	push	r1
 d70:	8c 80       	ldd	r8, Y+4	; 0x04
 d72:	9d 80       	ldd	r9, Y+5	; 0x05
 d74:	56 01       	movw	r10, r12
 d76:	ce 2c       	mov	r12, r14
 d78:	72 01       	movw	r14, r4
 d7a:	49 81       	ldd	r20, Y+1	; 0x01
 d7c:	5a 81       	ldd	r21, Y+2	; 0x02
 d7e:	6b 81       	ldd	r22, Y+3	; 0x03
 d80:	c3 01       	movw	r24, r6
 d82:	0e 94 ff 05 	call	0xbfe	; 0xbfe <prvInitialiseNewTask>
 d86:	8c 81       	ldd	r24, Y+4	; 0x04
 d88:	9d 81       	ldd	r25, Y+5	; 0x05
 d8a:	0e 94 82 05 	call	0xb04	; 0xb04 <prvAddNewTaskToReadyList>
 d8e:	0f 90       	pop	r0
 d90:	0f 90       	pop	r0
 d92:	0f 90       	pop	r0
 d94:	81 e0       	ldi	r24, 0x01	; 1
 d96:	01 c0       	rjmp	.+2      	; 0xd9a <xTaskCreate+0xb2>
 d98:	8f ef       	ldi	r24, 0xFF	; 255
 d9a:	0f 90       	pop	r0
 d9c:	0f 90       	pop	r0
 d9e:	0f 90       	pop	r0
 da0:	0f 90       	pop	r0
 da2:	0f 90       	pop	r0
 da4:	df 91       	pop	r29
 da6:	cf 91       	pop	r28
 da8:	1f 91       	pop	r17
 daa:	0f 91       	pop	r16
 dac:	ff 90       	pop	r15
 dae:	ef 90       	pop	r14
 db0:	df 90       	pop	r13
 db2:	cf 90       	pop	r12
 db4:	bf 90       	pop	r11
 db6:	af 90       	pop	r10
 db8:	9f 90       	pop	r9
 dba:	8f 90       	pop	r8
 dbc:	7f 90       	pop	r7
 dbe:	6f 90       	pop	r6
 dc0:	5f 90       	pop	r5
 dc2:	4f 90       	pop	r4
 dc4:	08 95       	ret

Disassembly of section .text.vTaskStartScheduler:

00001a98 <vTaskStartScheduler>:
    1a98:	cf 92       	push	r12
    1a9a:	df 92       	push	r13
    1a9c:	ef 92       	push	r14
    1a9e:	0f 93       	push	r16
    1aa0:	1f 93       	push	r17
    1aa2:	0f 2e       	mov	r0, r31
    1aa4:	f9 ea       	ldi	r31, 0xA9	; 169
    1aa6:	cf 2e       	mov	r12, r31
    1aa8:	f6 e0       	ldi	r31, 0x06	; 6
    1aaa:	df 2e       	mov	r13, r31
    1aac:	f0 2d       	mov	r31, r0
    1aae:	e1 2c       	mov	r14, r1
    1ab0:	00 e0       	ldi	r16, 0x00	; 0
    1ab2:	10 e0       	ldi	r17, 0x00	; 0
    1ab4:	25 e5       	ldi	r18, 0x55	; 85
    1ab6:	30 e0       	ldi	r19, 0x00	; 0
    1ab8:	4f ed       	ldi	r20, 0xDF	; 223
    1aba:	50 e0       	ldi	r21, 0x00	; 0
    1abc:	60 e0       	ldi	r22, 0x00	; 0
    1abe:	88 e1       	ldi	r24, 0x18	; 24
    1ac0:	91 e1       	ldi	r25, 0x11	; 17
    1ac2:	0e 94 74 06 	call	0xce8	; 0xce8 <xTaskCreate>
    1ac6:	81 30       	cpi	r24, 0x01	; 1
    1ac8:	11 f4       	brne	.+4      	; 0x1ace <vTaskStartScheduler+0x36>
    1aca:	0e 94 6a 0e 	call	0x1cd4	; 0x1cd4 <xTimerCreateTimerTask>
    1ace:	81 30       	cpi	r24, 0x01	; 1
    1ad0:	81 f4       	brne	.+32     	; 0x1af2 <vTaskStartScheduler+0x5a>
    1ad2:	f8 94       	cli
    1ad4:	8f ef       	ldi	r24, 0xFF	; 255
    1ad6:	9f ef       	ldi	r25, 0xFF	; 255
    1ad8:	90 93 ac 06 	sts	0x06AC, r25	; 0x8006ac <xNextTaskUnblockTime+0x1>
    1adc:	80 93 ab 06 	sts	0x06AB, r24	; 0x8006ab <xNextTaskUnblockTime>
    1ae0:	81 e0       	ldi	r24, 0x01	; 1
    1ae2:	80 93 c5 06 	sts	0x06C5, r24	; 0x8006c5 <xSchedulerRunning>
    1ae6:	10 92 b0 06 	sts	0x06B0, r1	; 0x8006b0 <xTickCount+0x1>
    1aea:	10 92 af 06 	sts	0x06AF, r1	; 0x8006af <xTickCount>
    1aee:	0e 94 e1 0d 	call	0x1bc2	; 0x1bc2 <xPortStartScheduler>
    1af2:	1f 91       	pop	r17
    1af4:	0f 91       	pop	r16
    1af6:	ef 90       	pop	r14
    1af8:	df 90       	pop	r13
    1afa:	cf 90       	pop	r12
    1afc:	08 95       	ret

Disassembly of section .text.vTaskSuspendAll:

000021f8 <vTaskSuspendAll>:
    21f8:	80 91 c1 06 	lds	r24, 0x06C1	; 0x8006c1 <uxSchedulerSuspended>
    21fc:	8f 5f       	subi	r24, 0xFF	; 255
    21fe:	80 93 c1 06 	sts	0x06C1, r24	; 0x8006c1 <uxSchedulerSuspended>
    2202:	08 95       	ret

Disassembly of section .text.xTaskGetTickCount:

000021b6 <xTaskGetTickCount>:
    21b6:	0f b6       	in	r0, 0x3f	; 63
    21b8:	f8 94       	cli
    21ba:	0f 92       	push	r0
    21bc:	80 91 af 06 	lds	r24, 0x06AF	; 0x8006af <xTickCount>
    21c0:	90 91 b0 06 	lds	r25, 0x06B0	; 0x8006b0 <xTickCount+0x1>
    21c4:	0f 90       	pop	r0
    21c6:	0f be       	out	0x3f, r0	; 63
    21c8:	08 95       	ret

Disassembly of section .text.uxTaskGetNumberOfTasks:

00002236 <uxTaskGetNumberOfTasks>:

UBaseType_t uxTaskGetNumberOfTasks( void )
{
    /* A critical section is not required because the variables are of type
     * BaseType_t. */
    return uxCurrentNumberOfTasks;
    2236:	80 91 c7 06 	lds	r24, 0x06C7	; 0x8006c7 <uxCurrentNumberOfTasks>
}
    223a:	08 95       	ret

Disassembly of section .text.xTaskIncrementTick:

000000e6 <xTaskIncrementTick>:
        xReturn = xTickCount;
    }
    portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
}
  e6:	0f 93       	push	r16
  e8:	1f 93       	push	r17
  ea:	cf 93       	push	r28
  ec:	df 93       	push	r29
  ee:	80 91 c1 06 	lds	r24, 0x06C1	; 0x8006c1 <uxSchedulerSuspended>
  f2:	81 11       	cpse	r24, r1
  f4:	01 c1       	rjmp	.+514    	; 0x2f8 <xTaskIncrementTick+0x212>
  f6:	c0 91 af 06 	lds	r28, 0x06AF	; 0x8006af <xTickCount>
  fa:	d0 91 b0 06 	lds	r29, 0x06B0	; 0x8006b0 <xTickCount+0x1>
  fe:	8e 01       	movw	r16, r28
 100:	0f 5f       	subi	r16, 0xFF	; 255
 102:	1f 4f       	sbci	r17, 0xFF	; 255
 104:	10 93 b0 06 	sts	0x06B0, r17	; 0x8006b0 <xTickCount+0x1>
 108:	00 93 af 06 	sts	0x06AF, r16	; 0x8006af <xTickCount>
 10c:	01 15       	cp	r16, r1
 10e:	11 05       	cpc	r17, r1
 110:	b9 f4       	brne	.+46     	; 0x140 <xTaskIncrementTick+0x5a>
 112:	80 91 b3 06 	lds	r24, 0x06B3	; 0x8006b3 <pxDelayedTaskList>
 116:	90 91 b4 06 	lds	r25, 0x06B4	; 0x8006b4 <pxDelayedTaskList+0x1>
 11a:	20 91 b1 06 	lds	r18, 0x06B1	; 0x8006b1 <pxOverflowDelayedTaskList>
 11e:	30 91 b2 06 	lds	r19, 0x06B2	; 0x8006b2 <pxOverflowDelayedTaskList+0x1>
 122:	30 93 b4 06 	sts	0x06B4, r19	; 0x8006b4 <pxDelayedTaskList+0x1>
 126:	20 93 b3 06 	sts	0x06B3, r18	; 0x8006b3 <pxDelayedTaskList>
 12a:	90 93 b2 06 	sts	0x06B2, r25	; 0x8006b2 <pxOverflowDelayedTaskList+0x1>
 12e:	80 93 b1 06 	sts	0x06B1, r24	; 0x8006b1 <pxOverflowDelayedTaskList>
 132:	80 91 c3 06 	lds	r24, 0x06C3	; 0x8006c3 <xNumOfOverflows>
 136:	8f 5f       	subi	r24, 0xFF	; 255
 138:	80 93 c3 06 	sts	0x06C3, r24	; 0x8006c3 <xNumOfOverflows>
 13c:	0e 94 c7 0f 	call	0x1f8e	; 0x1f8e <prvResetNextTaskUnblockTime>
 140:	80 91 ab 06 	lds	r24, 0x06AB	; 0x8006ab <xNextTaskUnblockTime>
 144:	90 91 ac 06 	lds	r25, 0x06AC	; 0x8006ac <xNextTaskUnblockTime+0x1>
 148:	08 17       	cp	r16, r24
 14a:	19 07       	cpc	r17, r25
 14c:	20 f4       	brcc	.+8      	; 0x156 <xTaskIncrementTick+0x70>
 14e:	80 e0       	ldi	r24, 0x00	; 0
 150:	b8 c0       	rjmp	.+368    	; 0x2c2 <xTaskIncrementTick+0x1dc>
 152:	81 e0       	ldi	r24, 0x01	; 1
 154:	01 c0       	rjmp	.+2      	; 0x158 <xTaskIncrementTick+0x72>
 156:	80 e0       	ldi	r24, 0x00	; 0
 158:	e0 91 b3 06 	lds	r30, 0x06B3	; 0x8006b3 <pxDelayedTaskList>
 15c:	f0 91 b4 06 	lds	r31, 0x06B4	; 0x8006b4 <pxDelayedTaskList+0x1>
 160:	90 81       	ld	r25, Z
 162:	91 11       	cpse	r25, r1
 164:	07 c0       	rjmp	.+14     	; 0x174 <xTaskIncrementTick+0x8e>
 166:	2f ef       	ldi	r18, 0xFF	; 255
 168:	3f ef       	ldi	r19, 0xFF	; 255
 16a:	30 93 ac 06 	sts	0x06AC, r19	; 0x8006ac <xNextTaskUnblockTime+0x1>
 16e:	20 93 ab 06 	sts	0x06AB, r18	; 0x8006ab <xNextTaskUnblockTime>
 172:	a7 c0       	rjmp	.+334    	; 0x2c2 <xTaskIncrementTick+0x1dc>
 174:	e0 91 b3 06 	lds	r30, 0x06B3	; 0x8006b3 <pxDelayedTaskList>
 178:	f0 91 b4 06 	lds	r31, 0x06B4	; 0x8006b4 <pxDelayedTaskList+0x1>
 17c:	05 80       	ldd	r0, Z+5	; 0x05
 17e:	f6 81       	ldd	r31, Z+6	; 0x06
 180:	e0 2d       	mov	r30, r0
 182:	06 80       	ldd	r0, Z+6	; 0x06
 184:	f7 81       	ldd	r31, Z+7	; 0x07
 186:	e0 2d       	mov	r30, r0
 188:	22 81       	ldd	r18, Z+2	; 0x02
 18a:	33 81       	ldd	r19, Z+3	; 0x03
 18c:	02 17       	cp	r16, r18
 18e:	13 07       	cpc	r17, r19
 190:	28 f4       	brcc	.+10     	; 0x19c <xTaskIncrementTick+0xb6>
 192:	30 93 ac 06 	sts	0x06AC, r19	; 0x8006ac <xNextTaskUnblockTime+0x1>
 196:	20 93 ab 06 	sts	0x06AB, r18	; 0x8006ab <xNextTaskUnblockTime>
 19a:	93 c0       	rjmp	.+294    	; 0x2c2 <xTaskIncrementTick+0x1dc>
 19c:	a2 85       	ldd	r26, Z+10	; 0x0a
 19e:	b3 85       	ldd	r27, Z+11	; 0x0b
 1a0:	24 81       	ldd	r18, Z+4	; 0x04
 1a2:	35 81       	ldd	r19, Z+5	; 0x05
 1a4:	46 81       	ldd	r20, Z+6	; 0x06
 1a6:	57 81       	ldd	r21, Z+7	; 0x07
 1a8:	e9 01       	movw	r28, r18
 1aa:	5d 83       	std	Y+5, r21	; 0x05
 1ac:	4c 83       	std	Y+4, r20	; 0x04
 1ae:	26 81       	ldd	r18, Z+6	; 0x06
 1b0:	37 81       	ldd	r19, Z+7	; 0x07
 1b2:	44 81       	ldd	r20, Z+4	; 0x04
 1b4:	55 81       	ldd	r21, Z+5	; 0x05
 1b6:	e9 01       	movw	r28, r18
 1b8:	5b 83       	std	Y+3, r21	; 0x03
 1ba:	4a 83       	std	Y+2, r20	; 0x02
 1bc:	11 96       	adiw	r26, 0x01	; 1
 1be:	2d 91       	ld	r18, X+
 1c0:	3c 91       	ld	r19, X
 1c2:	12 97       	sbiw	r26, 0x02	; 2
 1c4:	af 01       	movw	r20, r30
 1c6:	4e 5f       	subi	r20, 0xFE	; 254
 1c8:	5f 4f       	sbci	r21, 0xFF	; 255
 1ca:	24 17       	cp	r18, r20
 1cc:	35 07       	cpc	r19, r21
 1ce:	31 f4       	brne	.+12     	; 0x1dc <xTaskIncrementTick+0xf6>
 1d0:	26 81       	ldd	r18, Z+6	; 0x06
 1d2:	37 81       	ldd	r19, Z+7	; 0x07
 1d4:	12 96       	adiw	r26, 0x02	; 2
 1d6:	3c 93       	st	X, r19
 1d8:	2e 93       	st	-X, r18
 1da:	11 97       	sbiw	r26, 0x01	; 1
 1dc:	13 86       	std	Z+11, r1	; 0x0b
 1de:	12 86       	std	Z+10, r1	; 0x0a
 1e0:	9c 91       	ld	r25, X
 1e2:	91 50       	subi	r25, 0x01	; 1
 1e4:	9c 93       	st	X, r25
 1e6:	a4 89       	ldd	r26, Z+20	; 0x14
 1e8:	b5 89       	ldd	r27, Z+21	; 0x15
 1ea:	10 97       	sbiw	r26, 0x00	; 0
 1ec:	19 f1       	breq	.+70     	; 0x234 <xTaskIncrementTick+0x14e>
 1ee:	26 85       	ldd	r18, Z+14	; 0x0e
 1f0:	37 85       	ldd	r19, Z+15	; 0x0f
 1f2:	60 89       	ldd	r22, Z+16	; 0x10
 1f4:	71 89       	ldd	r23, Z+17	; 0x11
 1f6:	e9 01       	movw	r28, r18
 1f8:	7d 83       	std	Y+5, r23	; 0x05
 1fa:	6c 83       	std	Y+4, r22	; 0x04
 1fc:	20 89       	ldd	r18, Z+16	; 0x10
 1fe:	31 89       	ldd	r19, Z+17	; 0x11
 200:	66 85       	ldd	r22, Z+14	; 0x0e
 202:	77 85       	ldd	r23, Z+15	; 0x0f
 204:	e9 01       	movw	r28, r18
 206:	7b 83       	std	Y+3, r23	; 0x03
 208:	6a 83       	std	Y+2, r22	; 0x02
 20a:	11 96       	adiw	r26, 0x01	; 1
 20c:	6d 91       	ld	r22, X+
 20e:	7c 91       	ld	r23, X
 210:	12 97       	sbiw	r26, 0x02	; 2
 212:	9f 01       	movw	r18, r30
 214:	24 5f       	subi	r18, 0xF4	; 244
 216:	3f 4f       	sbci	r19, 0xFF	; 255
 218:	62 17       	cp	r22, r18
 21a:	73 07       	cpc	r23, r19
 21c:	31 f4       	brne	.+12     	; 0x22a <xTaskIncrementTick+0x144>
 21e:	20 89       	ldd	r18, Z+16	; 0x10
 220:	31 89       	ldd	r19, Z+17	; 0x11
 222:	12 96       	adiw	r26, 0x02	; 2
 224:	3c 93       	st	X, r19
 226:	2e 93       	st	-X, r18
 228:	11 97       	sbiw	r26, 0x01	; 1
 22a:	15 8a       	std	Z+21, r1	; 0x15
 22c:	14 8a       	std	Z+20, r1	; 0x14
 22e:	9c 91       	ld	r25, X
 230:	91 50       	subi	r25, 0x01	; 1
 232:	9c 93       	st	X, r25
 234:	26 89       	ldd	r18, Z+22	; 0x16
 236:	90 91 c6 06 	lds	r25, 0x06C6	; 0x8006c6 <uxTopReadyPriority>
 23a:	92 17       	cp	r25, r18
 23c:	10 f4       	brcc	.+4      	; 0x242 <xTaskIncrementTick+0x15c>
 23e:	20 93 c6 06 	sts	0x06C6, r18	; 0x8006c6 <uxTopReadyPriority>
 242:	30 e0       	ldi	r19, 0x00	; 0
 244:	d9 01       	movw	r26, r18
 246:	aa 0f       	add	r26, r26
 248:	bb 1f       	adc	r27, r27
 24a:	aa 0f       	add	r26, r26
 24c:	bb 1f       	adc	r27, r27
 24e:	aa 0f       	add	r26, r26
 250:	bb 1f       	adc	r27, r27
 252:	2a 0f       	add	r18, r26
 254:	3b 1f       	adc	r19, r27
 256:	d9 01       	movw	r26, r18
 258:	ae 5b       	subi	r26, 0xBE	; 190
 25a:	b9 4f       	sbci	r27, 0xF9	; 249
 25c:	11 96       	adiw	r26, 0x01	; 1
 25e:	0d 90       	ld	r0, X+
 260:	bc 91       	ld	r27, X
 262:	a0 2d       	mov	r26, r0
 264:	b5 83       	std	Z+5, r27	; 0x05
 266:	a4 83       	std	Z+4, r26	; 0x04
 268:	14 96       	adiw	r26, 0x04	; 4
 26a:	2d 91       	ld	r18, X+
 26c:	3c 91       	ld	r19, X
 26e:	15 97       	sbiw	r26, 0x05	; 5
 270:	37 83       	std	Z+7, r19	; 0x07
 272:	26 83       	std	Z+6, r18	; 0x06
 274:	14 96       	adiw	r26, 0x04	; 4
 276:	2d 91       	ld	r18, X+
 278:	3c 91       	ld	r19, X
 27a:	15 97       	sbiw	r26, 0x05	; 5
 27c:	e9 01       	movw	r28, r18
 27e:	5b 83       	std	Y+3, r21	; 0x03
 280:	4a 83       	std	Y+2, r20	; 0x02
 282:	15 96       	adiw	r26, 0x05	; 5
 284:	5c 93       	st	X, r21
 286:	4e 93       	st	-X, r20
 288:	14 97       	sbiw	r26, 0x04	; 4
 28a:	a6 89       	ldd	r26, Z+22	; 0x16
 28c:	b0 e0       	ldi	r27, 0x00	; 0
 28e:	9d 01       	movw	r18, r26
 290:	22 0f       	add	r18, r18
 292:	33 1f       	adc	r19, r19
 294:	22 0f       	add	r18, r18
 296:	33 1f       	adc	r19, r19
 298:	22 0f       	add	r18, r18
 29a:	33 1f       	adc	r19, r19
 29c:	a2 0f       	add	r26, r18
 29e:	b3 1f       	adc	r27, r19
 2a0:	ae 5b       	subi	r26, 0xBE	; 190
 2a2:	b9 4f       	sbci	r27, 0xF9	; 249
 2a4:	b3 87       	std	Z+11, r27	; 0x0b
 2a6:	a2 87       	std	Z+10, r26	; 0x0a
 2a8:	9c 91       	ld	r25, X
 2aa:	9f 5f       	subi	r25, 0xFF	; 255
 2ac:	9c 93       	st	X, r25
 2ae:	26 89       	ldd	r18, Z+22	; 0x16
 2b0:	e0 91 b5 06 	lds	r30, 0x06B5	; 0x8006b5 <pxCurrentTCB>
 2b4:	f0 91 b6 06 	lds	r31, 0x06B6	; 0x8006b6 <pxCurrentTCB+0x1>
 2b8:	96 89       	ldd	r25, Z+22	; 0x16
 2ba:	92 17       	cp	r25, r18
 2bc:	08 f4       	brcc	.+2      	; 0x2c0 <xTaskIncrementTick+0x1da>
 2be:	49 cf       	rjmp	.-366    	; 0x152 <xTaskIncrementTick+0x6c>
 2c0:	4b cf       	rjmp	.-362    	; 0x158 <xTaskIncrementTick+0x72>
 2c2:	e0 91 b5 06 	lds	r30, 0x06B5	; 0x8006b5 <pxCurrentTCB>
 2c6:	f0 91 b6 06 	lds	r31, 0x06B6	; 0x8006b6 <pxCurrentTCB+0x1>
 2ca:	26 89       	ldd	r18, Z+22	; 0x16
 2cc:	30 e0       	ldi	r19, 0x00	; 0
 2ce:	f9 01       	movw	r30, r18
 2d0:	ee 0f       	add	r30, r30
 2d2:	ff 1f       	adc	r31, r31
 2d4:	ee 0f       	add	r30, r30
 2d6:	ff 1f       	adc	r31, r31
 2d8:	ee 0f       	add	r30, r30
 2da:	ff 1f       	adc	r31, r31
 2dc:	2e 0f       	add	r18, r30
 2de:	3f 1f       	adc	r19, r31
 2e0:	f9 01       	movw	r30, r18
 2e2:	ee 5b       	subi	r30, 0xBE	; 190
 2e4:	f9 4f       	sbci	r31, 0xF9	; 249
 2e6:	90 81       	ld	r25, Z
 2e8:	92 30       	cpi	r25, 0x02	; 2
 2ea:	08 f0       	brcs	.+2      	; 0x2ee <xTaskIncrementTick+0x208>
 2ec:	81 e0       	ldi	r24, 0x01	; 1
 2ee:	90 91 c4 06 	lds	r25, 0x06C4	; 0x8006c4 <xYieldPending>
 2f2:	91 11       	cpse	r25, r1
 2f4:	0c c0       	rjmp	.+24     	; 0x30e <xTaskIncrementTick+0x228>
 2f6:	0c c0       	rjmp	.+24     	; 0x310 <xTaskIncrementTick+0x22a>
 2f8:	80 91 ad 06 	lds	r24, 0x06AD	; 0x8006ad <xPendedTicks>
 2fc:	90 91 ae 06 	lds	r25, 0x06AE	; 0x8006ae <xPendedTicks+0x1>
 300:	01 96       	adiw	r24, 0x01	; 1
 302:	90 93 ae 06 	sts	0x06AE, r25	; 0x8006ae <xPendedTicks+0x1>
 306:	80 93 ad 06 	sts	0x06AD, r24	; 0x8006ad <xPendedTicks>
 30a:	80 e0       	ldi	r24, 0x00	; 0
 30c:	01 c0       	rjmp	.+2      	; 0x310 <xTaskIncrementTick+0x22a>
 30e:	81 e0       	ldi	r24, 0x01	; 1
 310:	df 91       	pop	r29
 312:	cf 91       	pop	r28
 314:	1f 91       	pop	r17
 316:	0f 91       	pop	r16
 318:	08 95       	ret

Disassembly of section .text.xTaskResumeAll:

0000031a <xTaskResumeAll>:
 31a:	cf 93       	push	r28
 31c:	df 93       	push	r29
 31e:	0f b6       	in	r0, 0x3f	; 63
 320:	f8 94       	cli
 322:	0f 92       	push	r0
 324:	80 91 c1 06 	lds	r24, 0x06C1	; 0x8006c1 <uxSchedulerSuspended>
 328:	81 50       	subi	r24, 0x01	; 1
 32a:	80 93 c1 06 	sts	0x06C1, r24	; 0x8006c1 <uxSchedulerSuspended>
 32e:	80 91 c1 06 	lds	r24, 0x06C1	; 0x8006c1 <uxSchedulerSuspended>
 332:	81 11       	cpse	r24, r1
 334:	bf c0       	rjmp	.+382    	; 0x4b4 <__EEPROM_REGION_LENGTH__+0xb4>
 336:	80 91 c7 06 	lds	r24, 0x06C7	; 0x8006c7 <uxCurrentNumberOfTasks>
 33a:	81 11       	cpse	r24, r1
 33c:	96 c0       	rjmp	.+300    	; 0x46a <__EEPROM_REGION_LENGTH__+0x6a>
 33e:	bd c0       	rjmp	.+378    	; 0x4ba <__EEPROM_REGION_LENGTH__+0xba>
 340:	e0 91 7d 06 	lds	r30, 0x067D	; 0x80067d <xPendingReadyList+0x5>
 344:	f0 91 7e 06 	lds	r31, 0x067E	; 0x80067e <xPendingReadyList+0x6>
 348:	06 80       	ldd	r0, Z+6	; 0x06
 34a:	f7 81       	ldd	r31, Z+7	; 0x07
 34c:	e0 2d       	mov	r30, r0
 34e:	a4 89       	ldd	r26, Z+20	; 0x14
 350:	b5 89       	ldd	r27, Z+21	; 0x15
 352:	c6 85       	ldd	r28, Z+14	; 0x0e
 354:	d7 85       	ldd	r29, Z+15	; 0x0f
 356:	80 89       	ldd	r24, Z+16	; 0x10
 358:	91 89       	ldd	r25, Z+17	; 0x11
 35a:	9d 83       	std	Y+5, r25	; 0x05
 35c:	8c 83       	std	Y+4, r24	; 0x04
 35e:	c0 89       	ldd	r28, Z+16	; 0x10
 360:	d1 89       	ldd	r29, Z+17	; 0x11
 362:	86 85       	ldd	r24, Z+14	; 0x0e
 364:	97 85       	ldd	r25, Z+15	; 0x0f
 366:	9b 83       	std	Y+3, r25	; 0x03
 368:	8a 83       	std	Y+2, r24	; 0x02
 36a:	11 96       	adiw	r26, 0x01	; 1
 36c:	2d 91       	ld	r18, X+
 36e:	3c 91       	ld	r19, X
 370:	12 97       	sbiw	r26, 0x02	; 2
 372:	cf 01       	movw	r24, r30
 374:	0c 96       	adiw	r24, 0x0c	; 12
 376:	28 17       	cp	r18, r24
 378:	39 07       	cpc	r19, r25
 37a:	31 f4       	brne	.+12     	; 0x388 <xTaskResumeAll+0x6e>
 37c:	80 89       	ldd	r24, Z+16	; 0x10
 37e:	91 89       	ldd	r25, Z+17	; 0x11
 380:	12 96       	adiw	r26, 0x02	; 2
 382:	9c 93       	st	X, r25
 384:	8e 93       	st	-X, r24
 386:	11 97       	sbiw	r26, 0x01	; 1
 388:	15 8a       	std	Z+21, r1	; 0x15
 38a:	14 8a       	std	Z+20, r1	; 0x14
 38c:	8c 91       	ld	r24, X
 38e:	81 50       	subi	r24, 0x01	; 1
 390:	8c 93       	st	X, r24
 392:	a2 85       	ldd	r26, Z+10	; 0x0a
 394:	b3 85       	ldd	r27, Z+11	; 0x0b
 396:	c4 81       	ldd	r28, Z+4	; 0x04
 398:	d5 81       	ldd	r29, Z+5	; 0x05
 39a:	86 81       	ldd	r24, Z+6	; 0x06
 39c:	97 81       	ldd	r25, Z+7	; 0x07
 39e:	9d 83       	std	Y+5, r25	; 0x05
 3a0:	8c 83       	std	Y+4, r24	; 0x04
 3a2:	c6 81       	ldd	r28, Z+6	; 0x06
 3a4:	d7 81       	ldd	r29, Z+7	; 0x07
 3a6:	84 81       	ldd	r24, Z+4	; 0x04
 3a8:	95 81       	ldd	r25, Z+5	; 0x05
 3aa:	9b 83       	std	Y+3, r25	; 0x03
 3ac:	8a 83       	std	Y+2, r24	; 0x02
 3ae:	11 96       	adiw	r26, 0x01	; 1
 3b0:	8d 91       	ld	r24, X+
 3b2:	9c 91       	ld	r25, X
 3b4:	12 97       	sbiw	r26, 0x02	; 2
 3b6:	9f 01       	movw	r18, r30
 3b8:	2e 5f       	subi	r18, 0xFE	; 254
 3ba:	3f 4f       	sbci	r19, 0xFF	; 255
 3bc:	82 17       	cp	r24, r18
 3be:	93 07       	cpc	r25, r19
 3c0:	31 f4       	brne	.+12     	; 0x3ce <xTaskResumeAll+0xb4>
 3c2:	86 81       	ldd	r24, Z+6	; 0x06
 3c4:	97 81       	ldd	r25, Z+7	; 0x07
 3c6:	12 96       	adiw	r26, 0x02	; 2
 3c8:	9c 93       	st	X, r25
 3ca:	8e 93       	st	-X, r24
 3cc:	11 97       	sbiw	r26, 0x01	; 1
 3ce:	13 86       	std	Z+11, r1	; 0x0b
 3d0:	12 86       	std	Z+10, r1	; 0x0a
 3d2:	8c 91       	ld	r24, X
 3d4:	81 50       	subi	r24, 0x01	; 1
 3d6:	8c 93       	st	X, r24
 3d8:	86 89       	ldd	r24, Z+22	; 0x16
 3da:	90 91 c6 06 	lds	r25, 0x06C6	; 0x8006c6 <uxTopReadyPriority>
 3de:	98 17       	cp	r25, r24
 3e0:	10 f4       	brcc	.+4      	; 0x3e6 <xTaskResumeAll+0xcc>
 3e2:	80 93 c6 06 	sts	0x06C6, r24	; 0x8006c6 <uxTopReadyPriority>
 3e6:	90 e0       	ldi	r25, 0x00	; 0
 3e8:	dc 01       	movw	r26, r24
 3ea:	aa 0f       	add	r26, r26
 3ec:	bb 1f       	adc	r27, r27
 3ee:	aa 0f       	add	r26, r26
 3f0:	bb 1f       	adc	r27, r27
 3f2:	aa 0f       	add	r26, r26
 3f4:	bb 1f       	adc	r27, r27
 3f6:	8a 0f       	add	r24, r26
 3f8:	9b 1f       	adc	r25, r27
 3fa:	dc 01       	movw	r26, r24
 3fc:	ae 5b       	subi	r26, 0xBE	; 190
 3fe:	b9 4f       	sbci	r27, 0xF9	; 249
 400:	11 96       	adiw	r26, 0x01	; 1
 402:	0d 90       	ld	r0, X+
 404:	bc 91       	ld	r27, X
 406:	a0 2d       	mov	r26, r0
 408:	b5 83       	std	Z+5, r27	; 0x05
 40a:	a4 83       	std	Z+4, r26	; 0x04
 40c:	14 96       	adiw	r26, 0x04	; 4
 40e:	8d 91       	ld	r24, X+
 410:	9c 91       	ld	r25, X
 412:	15 97       	sbiw	r26, 0x05	; 5
 414:	97 83       	std	Z+7, r25	; 0x07
 416:	86 83       	std	Z+6, r24	; 0x06
 418:	14 96       	adiw	r26, 0x04	; 4
 41a:	cd 91       	ld	r28, X+
 41c:	dc 91       	ld	r29, X
 41e:	15 97       	sbiw	r26, 0x05	; 5
 420:	3b 83       	std	Y+3, r19	; 0x03
 422:	2a 83       	std	Y+2, r18	; 0x02
 424:	15 96       	adiw	r26, 0x05	; 5
 426:	3c 93       	st	X, r19
 428:	2e 93       	st	-X, r18
 42a:	14 97       	sbiw	r26, 0x04	; 4
 42c:	a6 89       	ldd	r26, Z+22	; 0x16
 42e:	b0 e0       	ldi	r27, 0x00	; 0
 430:	cd 01       	movw	r24, r26
 432:	88 0f       	add	r24, r24
 434:	99 1f       	adc	r25, r25
 436:	88 0f       	add	r24, r24
 438:	99 1f       	adc	r25, r25
 43a:	88 0f       	add	r24, r24
 43c:	99 1f       	adc	r25, r25
 43e:	a8 0f       	add	r26, r24
 440:	b9 1f       	adc	r27, r25
 442:	ae 5b       	subi	r26, 0xBE	; 190
 444:	b9 4f       	sbci	r27, 0xF9	; 249
 446:	b3 87       	std	Z+11, r27	; 0x0b
 448:	a2 87       	std	Z+10, r26	; 0x0a
 44a:	8c 91       	ld	r24, X
 44c:	8f 5f       	subi	r24, 0xFF	; 255
 44e:	8c 93       	st	X, r24
 450:	96 89       	ldd	r25, Z+22	; 0x16
 452:	a0 91 b5 06 	lds	r26, 0x06B5	; 0x8006b5 <pxCurrentTCB>
 456:	b0 91 b6 06 	lds	r27, 0x06B6	; 0x8006b6 <pxCurrentTCB+0x1>
 45a:	56 96       	adiw	r26, 0x16	; 22
 45c:	8c 91       	ld	r24, X
 45e:	98 17       	cp	r25, r24
 460:	30 f0       	brcs	.+12     	; 0x46e <__EEPROM_REGION_LENGTH__+0x6e>
 462:	81 e0       	ldi	r24, 0x01	; 1
 464:	80 93 c4 06 	sts	0x06C4, r24	; 0x8006c4 <xYieldPending>
 468:	02 c0       	rjmp	.+4      	; 0x46e <__EEPROM_REGION_LENGTH__+0x6e>
 46a:	e0 e0       	ldi	r30, 0x00	; 0
 46c:	f0 e0       	ldi	r31, 0x00	; 0
 46e:	80 91 78 06 	lds	r24, 0x0678	; 0x800678 <xPendingReadyList>
 472:	81 11       	cpse	r24, r1
 474:	65 cf       	rjmp	.-310    	; 0x340 <xTaskResumeAll+0x26>
 476:	ef 2b       	or	r30, r31
 478:	11 f0       	breq	.+4      	; 0x47e <__EEPROM_REGION_LENGTH__+0x7e>
 47a:	0e 94 c7 0f 	call	0x1f8e	; 0x1f8e <prvResetNextTaskUnblockTime>
 47e:	c0 91 ad 06 	lds	r28, 0x06AD	; 0x8006ad <xPendedTicks>
 482:	d0 91 ae 06 	lds	r29, 0x06AE	; 0x8006ae <xPendedTicks+0x1>
 486:	20 97       	sbiw	r28, 0x00	; 0
 488:	69 f0       	breq	.+26     	; 0x4a4 <__EEPROM_REGION_LENGTH__+0xa4>
 48a:	0e 94 73 00 	call	0xe6	; 0xe6 <xTaskIncrementTick>
 48e:	88 23       	and	r24, r24
 490:	19 f0       	breq	.+6      	; 0x498 <__EEPROM_REGION_LENGTH__+0x98>
 492:	81 e0       	ldi	r24, 0x01	; 1
 494:	80 93 c4 06 	sts	0x06C4, r24	; 0x8006c4 <xYieldPending>
 498:	21 97       	sbiw	r28, 0x01	; 1
 49a:	b9 f7       	brne	.-18     	; 0x48a <__EEPROM_REGION_LENGTH__+0x8a>
 49c:	10 92 ae 06 	sts	0x06AE, r1	; 0x8006ae <xPendedTicks+0x1>
 4a0:	10 92 ad 06 	sts	0x06AD, r1	; 0x8006ad <xPendedTicks>
 4a4:	80 91 c4 06 	lds	r24, 0x06C4	; 0x8006c4 <xYieldPending>
 4a8:	88 23       	and	r24, r24
 4aa:	31 f0       	breq	.+12     	; 0x4b8 <__EEPROM_REGION_LENGTH__+0xb8>
 4ac:	0e 94 cb 08 	call	0x1196	; 0x1196 <vPortYield>
 4b0:	81 e0       	ldi	r24, 0x01	; 1
 4b2:	03 c0       	rjmp	.+6      	; 0x4ba <__EEPROM_REGION_LENGTH__+0xba>
 4b4:	80 e0       	ldi	r24, 0x00	; 0
 4b6:	01 c0       	rjmp	.+2      	; 0x4ba <__EEPROM_REGION_LENGTH__+0xba>
 4b8:	80 e0       	ldi	r24, 0x00	; 0
 4ba:	0f 90       	pop	r0
 4bc:	0f be       	out	0x3f, r0	; 63
 4be:	df 91       	pop	r29
 4c0:	cf 91       	pop	r28
 4c2:	08 95       	ret

Disassembly of section .text.vTaskSwitchContext:

00001248 <vTaskSwitchContext>:
    1248:	80 91 c1 06 	lds	r24, 0x06C1	; 0x8006c1 <uxSchedulerSuspended>
    124c:	88 23       	and	r24, r24
    124e:	21 f0       	breq	.+8      	; 0x1258 <vTaskSwitchContext+0x10>
    1250:	81 e0       	ldi	r24, 0x01	; 1
    1252:	80 93 c4 06 	sts	0x06C4, r24	; 0x8006c4 <xYieldPending>
    1256:	08 95       	ret
    1258:	10 92 c4 06 	sts	0x06C4, r1	; 0x8006c4 <xYieldPending>
    125c:	20 91 c6 06 	lds	r18, 0x06C6	; 0x8006c6 <uxTopReadyPriority>
    1260:	01 c0       	rjmp	.+2      	; 0x1264 <vTaskSwitchContext+0x1c>
    1262:	21 50       	subi	r18, 0x01	; 1
    1264:	82 2f       	mov	r24, r18
    1266:	90 e0       	ldi	r25, 0x00	; 0
    1268:	fc 01       	movw	r30, r24
    126a:	ee 0f       	add	r30, r30
    126c:	ff 1f       	adc	r31, r31
    126e:	ee 0f       	add	r30, r30
    1270:	ff 1f       	adc	r31, r31
    1272:	ee 0f       	add	r30, r30
    1274:	ff 1f       	adc	r31, r31
    1276:	e8 0f       	add	r30, r24
    1278:	f9 1f       	adc	r31, r25
    127a:	ee 5b       	subi	r30, 0xBE	; 190
    127c:	f9 4f       	sbci	r31, 0xF9	; 249
    127e:	30 81       	ld	r19, Z
    1280:	33 23       	and	r19, r19
    1282:	79 f3       	breq	.-34     	; 0x1262 <vTaskSwitchContext+0x1a>
    1284:	ac 01       	movw	r20, r24
    1286:	44 0f       	add	r20, r20
    1288:	55 1f       	adc	r21, r21
    128a:	44 0f       	add	r20, r20
    128c:	55 1f       	adc	r21, r21
    128e:	44 0f       	add	r20, r20
    1290:	55 1f       	adc	r21, r21
    1292:	48 0f       	add	r20, r24
    1294:	59 1f       	adc	r21, r25
    1296:	df 01       	movw	r26, r30
    1298:	01 80       	ldd	r0, Z+1	; 0x01
    129a:	f2 81       	ldd	r31, Z+2	; 0x02
    129c:	e0 2d       	mov	r30, r0
    129e:	02 80       	ldd	r0, Z+2	; 0x02
    12a0:	f3 81       	ldd	r31, Z+3	; 0x03
    12a2:	e0 2d       	mov	r30, r0
    12a4:	12 96       	adiw	r26, 0x02	; 2
    12a6:	fc 93       	st	X, r31
    12a8:	ee 93       	st	-X, r30
    12aa:	11 97       	sbiw	r26, 0x01	; 1
    12ac:	4b 5b       	subi	r20, 0xBB	; 187
    12ae:	59 4f       	sbci	r21, 0xF9	; 249
    12b0:	e4 17       	cp	r30, r20
    12b2:	f5 07       	cpc	r31, r21
    12b4:	29 f4       	brne	.+10     	; 0x12c0 <vTaskSwitchContext+0x78>
    12b6:	42 81       	ldd	r20, Z+2	; 0x02
    12b8:	53 81       	ldd	r21, Z+3	; 0x03
    12ba:	fd 01       	movw	r30, r26
    12bc:	52 83       	std	Z+2, r21	; 0x02
    12be:	41 83       	std	Z+1, r20	; 0x01
    12c0:	fc 01       	movw	r30, r24
    12c2:	ee 0f       	add	r30, r30
    12c4:	ff 1f       	adc	r31, r31
    12c6:	ee 0f       	add	r30, r30
    12c8:	ff 1f       	adc	r31, r31
    12ca:	ee 0f       	add	r30, r30
    12cc:	ff 1f       	adc	r31, r31
    12ce:	8e 0f       	add	r24, r30
    12d0:	9f 1f       	adc	r25, r31
    12d2:	fc 01       	movw	r30, r24
    12d4:	ee 5b       	subi	r30, 0xBE	; 190
    12d6:	f9 4f       	sbci	r31, 0xF9	; 249
    12d8:	01 80       	ldd	r0, Z+1	; 0x01
    12da:	f2 81       	ldd	r31, Z+2	; 0x02
    12dc:	e0 2d       	mov	r30, r0
    12de:	86 81       	ldd	r24, Z+6	; 0x06
    12e0:	97 81       	ldd	r25, Z+7	; 0x07
    12e2:	90 93 b6 06 	sts	0x06B6, r25	; 0x8006b6 <pxCurrentTCB+0x1>
    12e6:	80 93 b5 06 	sts	0x06B5, r24	; 0x8006b5 <pxCurrentTCB>
    12ea:	20 93 c6 06 	sts	0x06C6, r18	; 0x8006c6 <uxTopReadyPriority>
    12ee:	08 95       	ret

Disassembly of section .text.vTaskPlaceOnEventList:

000020d8 <vTaskPlaceOnEventList>:
    20d8:	cf 93       	push	r28
    20da:	df 93       	push	r29
    20dc:	eb 01       	movw	r28, r22
    20de:	60 91 b5 06 	lds	r22, 0x06B5	; 0x8006b5 <pxCurrentTCB>
    20e2:	70 91 b6 06 	lds	r23, 0x06B6	; 0x8006b6 <pxCurrentTCB+0x1>
    20e6:	64 5f       	subi	r22, 0xF4	; 244
    20e8:	7f 4f       	sbci	r23, 0xFF	; 255
    20ea:	0e 94 7f 0d 	call	0x1afe	; 0x1afe <vListInsert>
    20ee:	61 e0       	ldi	r22, 0x01	; 1
    20f0:	ce 01       	movw	r24, r28
    20f2:	0e 94 01 05 	call	0xa02	; 0xa02 <prvAddCurrentTaskToDelayedList>
    20f6:	df 91       	pop	r29
    20f8:	cf 91       	pop	r28
    20fa:	08 95       	ret

Disassembly of section .text.vTaskPlaceOnEventListRestricted:

00001558 <vTaskPlaceOnEventListRestricted>:
    1558:	0f 93       	push	r16
    155a:	1f 93       	push	r17
    155c:	cf 93       	push	r28
    155e:	df 93       	push	r29
    1560:	fc 01       	movw	r30, r24
    1562:	8b 01       	movw	r16, r22
    1564:	a1 81       	ldd	r26, Z+1	; 0x01
    1566:	b2 81       	ldd	r27, Z+2	; 0x02
    1568:	80 91 b5 06 	lds	r24, 0x06B5	; 0x8006b5 <pxCurrentTCB>
    156c:	90 91 b6 06 	lds	r25, 0x06B6	; 0x8006b6 <pxCurrentTCB+0x1>
    1570:	ec 01       	movw	r28, r24
    1572:	bf 87       	std	Y+15, r27	; 0x0f
    1574:	ae 87       	std	Y+14, r26	; 0x0e
    1576:	80 91 b5 06 	lds	r24, 0x06B5	; 0x8006b5 <pxCurrentTCB>
    157a:	90 91 b6 06 	lds	r25, 0x06B6	; 0x8006b6 <pxCurrentTCB+0x1>
    157e:	14 96       	adiw	r26, 0x04	; 4
    1580:	2d 91       	ld	r18, X+
    1582:	3c 91       	ld	r19, X
    1584:	15 97       	sbiw	r26, 0x05	; 5
    1586:	ec 01       	movw	r28, r24
    1588:	39 8b       	std	Y+17, r19	; 0x11
    158a:	28 8b       	std	Y+16, r18	; 0x10
    158c:	14 96       	adiw	r26, 0x04	; 4
    158e:	8d 91       	ld	r24, X+
    1590:	9c 91       	ld	r25, X
    1592:	15 97       	sbiw	r26, 0x05	; 5
    1594:	20 91 b5 06 	lds	r18, 0x06B5	; 0x8006b5 <pxCurrentTCB>
    1598:	30 91 b6 06 	lds	r19, 0x06B6	; 0x8006b6 <pxCurrentTCB+0x1>
    159c:	24 5f       	subi	r18, 0xF4	; 244
    159e:	3f 4f       	sbci	r19, 0xFF	; 255
    15a0:	ec 01       	movw	r28, r24
    15a2:	3b 83       	std	Y+3, r19	; 0x03
    15a4:	2a 83       	std	Y+2, r18	; 0x02
    15a6:	20 91 b5 06 	lds	r18, 0x06B5	; 0x8006b5 <pxCurrentTCB>
    15aa:	30 91 b6 06 	lds	r19, 0x06B6	; 0x8006b6 <pxCurrentTCB+0x1>
    15ae:	24 5f       	subi	r18, 0xF4	; 244
    15b0:	3f 4f       	sbci	r19, 0xFF	; 255
    15b2:	15 96       	adiw	r26, 0x05	; 5
    15b4:	3c 93       	st	X, r19
    15b6:	2e 93       	st	-X, r18
    15b8:	14 97       	sbiw	r26, 0x04	; 4
    15ba:	a0 91 b5 06 	lds	r26, 0x06B5	; 0x8006b5 <pxCurrentTCB>
    15be:	b0 91 b6 06 	lds	r27, 0x06B6	; 0x8006b6 <pxCurrentTCB+0x1>
    15c2:	55 96       	adiw	r26, 0x15	; 21
    15c4:	fc 93       	st	X, r31
    15c6:	ee 93       	st	-X, r30
    15c8:	54 97       	sbiw	r26, 0x14	; 20
    15ca:	90 81       	ld	r25, Z
    15cc:	9f 5f       	subi	r25, 0xFF	; 255
    15ce:	90 83       	st	Z, r25
    15d0:	44 23       	and	r20, r20
    15d2:	11 f0       	breq	.+4      	; 0x15d8 <vTaskPlaceOnEventListRestricted+0x80>
    15d4:	0f ef       	ldi	r16, 0xFF	; 255
    15d6:	1f ef       	ldi	r17, 0xFF	; 255
    15d8:	64 2f       	mov	r22, r20
    15da:	c8 01       	movw	r24, r16
    15dc:	0e 94 01 05 	call	0xa02	; 0xa02 <prvAddCurrentTaskToDelayedList>
    15e0:	df 91       	pop	r29
    15e2:	cf 91       	pop	r28
    15e4:	1f 91       	pop	r17
    15e6:	0f 91       	pop	r16
    15e8:	08 95       	ret

Disassembly of section .text.xTaskRemoveFromEventList:

000004c4 <xTaskRemoveFromEventList>:
 4c4:	cf 93       	push	r28
 4c6:	df 93       	push	r29
 4c8:	a8 2f       	mov	r26, r24
 4ca:	cb 01       	movw	r24, r22
 4cc:	05 96       	adiw	r24, 0x05	; 5
 4ce:	a1 1d       	adc	r26, r1
 4d0:	fc 01       	movw	r30, r24
 4d2:	5a 2f       	mov	r21, r26
 4d4:	0e 94 ee 10 	call	0x21dc	; 0x21dc <__xload_2>
 4d8:	db 01       	movw	r26, r22
 4da:	16 96       	adiw	r26, 0x06	; 6
 4dc:	ed 91       	ld	r30, X+
 4de:	fc 91       	ld	r31, X
 4e0:	17 97       	sbiw	r26, 0x07	; 7
 4e2:	a4 89       	ldd	r26, Z+20	; 0x14
 4e4:	b5 89       	ldd	r27, Z+21	; 0x15
 4e6:	c6 85       	ldd	r28, Z+14	; 0x0e
 4e8:	d7 85       	ldd	r29, Z+15	; 0x0f
 4ea:	80 89       	ldd	r24, Z+16	; 0x10
 4ec:	91 89       	ldd	r25, Z+17	; 0x11
 4ee:	9d 83       	std	Y+5, r25	; 0x05
 4f0:	8c 83       	std	Y+4, r24	; 0x04
 4f2:	c0 89       	ldd	r28, Z+16	; 0x10
 4f4:	d1 89       	ldd	r29, Z+17	; 0x11
 4f6:	86 85       	ldd	r24, Z+14	; 0x0e
 4f8:	97 85       	ldd	r25, Z+15	; 0x0f
 4fa:	9b 83       	std	Y+3, r25	; 0x03
 4fc:	8a 83       	std	Y+2, r24	; 0x02
 4fe:	11 96       	adiw	r26, 0x01	; 1
 500:	8d 91       	ld	r24, X+
 502:	9c 91       	ld	r25, X
 504:	12 97       	sbiw	r26, 0x02	; 2
 506:	9f 01       	movw	r18, r30
 508:	24 5f       	subi	r18, 0xF4	; 244
 50a:	3f 4f       	sbci	r19, 0xFF	; 255
 50c:	82 17       	cp	r24, r18
 50e:	93 07       	cpc	r25, r19
 510:	31 f4       	brne	.+12     	; 0x51e <xTaskRemoveFromEventList+0x5a>
 512:	80 89       	ldd	r24, Z+16	; 0x10
 514:	91 89       	ldd	r25, Z+17	; 0x11
 516:	12 96       	adiw	r26, 0x02	; 2
 518:	9c 93       	st	X, r25
 51a:	8e 93       	st	-X, r24
 51c:	11 97       	sbiw	r26, 0x01	; 1
 51e:	15 8a       	std	Z+21, r1	; 0x15
 520:	14 8a       	std	Z+20, r1	; 0x14
 522:	8c 91       	ld	r24, X
 524:	81 50       	subi	r24, 0x01	; 1
 526:	8c 93       	st	X, r24
 528:	80 91 c1 06 	lds	r24, 0x06C1	; 0x8006c1 <uxSchedulerSuspended>
 52c:	81 11       	cpse	r24, r1
 52e:	60 c0       	rjmp	.+192    	; 0x5f0 <xTaskRemoveFromEventList+0x12c>
 530:	a2 85       	ldd	r26, Z+10	; 0x0a
 532:	b3 85       	ldd	r27, Z+11	; 0x0b
 534:	c4 81       	ldd	r28, Z+4	; 0x04
 536:	d5 81       	ldd	r29, Z+5	; 0x05
 538:	86 81       	ldd	r24, Z+6	; 0x06
 53a:	97 81       	ldd	r25, Z+7	; 0x07
 53c:	9d 83       	std	Y+5, r25	; 0x05
 53e:	8c 83       	std	Y+4, r24	; 0x04
 540:	c6 81       	ldd	r28, Z+6	; 0x06
 542:	d7 81       	ldd	r29, Z+7	; 0x07
 544:	84 81       	ldd	r24, Z+4	; 0x04
 546:	95 81       	ldd	r25, Z+5	; 0x05
 548:	9b 83       	std	Y+3, r25	; 0x03
 54a:	8a 83       	std	Y+2, r24	; 0x02
 54c:	11 96       	adiw	r26, 0x01	; 1
 54e:	8d 91       	ld	r24, X+
 550:	9c 91       	ld	r25, X
 552:	12 97       	sbiw	r26, 0x02	; 2
 554:	9f 01       	movw	r18, r30
 556:	2e 5f       	subi	r18, 0xFE	; 254
 558:	3f 4f       	sbci	r19, 0xFF	; 255
 55a:	82 17       	cp	r24, r18
 55c:	93 07       	cpc	r25, r19
 55e:	31 f4       	brne	.+12     	; 0x56c <xTaskRemoveFromEventList+0xa8>
 560:	86 81       	ldd	r24, Z+6	; 0x06
 562:	97 81       	ldd	r25, Z+7	; 0x07
 564:	12 96       	adiw	r26, 0x02	; 2
 566:	9c 93       	st	X, r25
 568:	8e 93       	st	-X, r24
 56a:	11 97       	sbiw	r26, 0x01	; 1
 56c:	13 86       	std	Z+11, r1	; 0x0b
 56e:	12 86       	std	Z+10, r1	; 0x0a
 570:	8c 91       	ld	r24, X
 572:	81 50       	subi	r24, 0x01	; 1
 574:	8c 93       	st	X, r24
 576:	86 89       	ldd	r24, Z+22	; 0x16
 578:	90 91 c6 06 	lds	r25, 0x06C6	; 0x8006c6 <uxTopReadyPriority>
 57c:	98 17       	cp	r25, r24
 57e:	10 f4       	brcc	.+4      	; 0x584 <xTaskRemoveFromEventList+0xc0>
 580:	80 93 c6 06 	sts	0x06C6, r24	; 0x8006c6 <uxTopReadyPriority>
 584:	90 e0       	ldi	r25, 0x00	; 0
 586:	dc 01       	movw	r26, r24
 588:	aa 0f       	add	r26, r26
 58a:	bb 1f       	adc	r27, r27
 58c:	aa 0f       	add	r26, r26
 58e:	bb 1f       	adc	r27, r27
 590:	aa 0f       	add	r26, r26
 592:	bb 1f       	adc	r27, r27
 594:	8a 0f       	add	r24, r26
 596:	9b 1f       	adc	r25, r27
 598:	dc 01       	movw	r26, r24
 59a:	ae 5b       	subi	r26, 0xBE	; 190
 59c:	b9 4f       	sbci	r27, 0xF9	; 249
 59e:	11 96       	adiw	r26, 0x01	; 1
 5a0:	0d 90       	ld	r0, X+
 5a2:	bc 91       	ld	r27, X
 5a4:	a0 2d       	mov	r26, r0
 5a6:	b5 83       	std	Z+5, r27	; 0x05
 5a8:	a4 83       	std	Z+4, r26	; 0x04
 5aa:	14 96       	adiw	r26, 0x04	; 4
 5ac:	8d 91       	ld	r24, X+
 5ae:	9c 91       	ld	r25, X
 5b0:	15 97       	sbiw	r26, 0x05	; 5
 5b2:	97 83       	std	Z+7, r25	; 0x07
 5b4:	86 83       	std	Z+6, r24	; 0x06
 5b6:	14 96       	adiw	r26, 0x04	; 4
 5b8:	cd 91       	ld	r28, X+
 5ba:	dc 91       	ld	r29, X
 5bc:	15 97       	sbiw	r26, 0x05	; 5
 5be:	3b 83       	std	Y+3, r19	; 0x03
 5c0:	2a 83       	std	Y+2, r18	; 0x02
 5c2:	15 96       	adiw	r26, 0x05	; 5
 5c4:	3c 93       	st	X, r19
 5c6:	2e 93       	st	-X, r18
 5c8:	14 97       	sbiw	r26, 0x04	; 4
 5ca:	a6 89       	ldd	r26, Z+22	; 0x16
 5cc:	b0 e0       	ldi	r27, 0x00	; 0
 5ce:	cd 01       	movw	r24, r26
 5d0:	88 0f       	add	r24, r24
 5d2:	99 1f       	adc	r25, r25
 5d4:	88 0f       	add	r24, r24
 5d6:	99 1f       	adc	r25, r25
 5d8:	88 0f       	add	r24, r24
 5da:	99 1f       	adc	r25, r25
 5dc:	a8 0f       	add	r26, r24
 5de:	b9 1f       	adc	r27, r25
 5e0:	ae 5b       	subi	r26, 0xBE	; 190
 5e2:	b9 4f       	sbci	r27, 0xF9	; 249
 5e4:	b3 87       	std	Z+11, r27	; 0x0b
 5e6:	a2 87       	std	Z+10, r26	; 0x0a
 5e8:	8c 91       	ld	r24, X
 5ea:	8f 5f       	subi	r24, 0xFF	; 255
 5ec:	8c 93       	st	X, r24
 5ee:	1c c0       	rjmp	.+56     	; 0x628 <xTaskRemoveFromEventList+0x164>
 5f0:	48 e7       	ldi	r20, 0x78	; 120
 5f2:	56 e0       	ldi	r21, 0x06	; 6
 5f4:	da 01       	movw	r26, r20
 5f6:	11 96       	adiw	r26, 0x01	; 1
 5f8:	cd 91       	ld	r28, X+
 5fa:	dc 91       	ld	r29, X
 5fc:	12 97       	sbiw	r26, 0x02	; 2
 5fe:	d7 87       	std	Z+15, r29	; 0x0f
 600:	c6 87       	std	Z+14, r28	; 0x0e
 602:	8c 81       	ldd	r24, Y+4	; 0x04
 604:	9d 81       	ldd	r25, Y+5	; 0x05
 606:	91 8b       	std	Z+17, r25	; 0x11
 608:	80 8b       	std	Z+16, r24	; 0x10
 60a:	8c 81       	ldd	r24, Y+4	; 0x04
 60c:	9d 81       	ldd	r25, Y+5	; 0x05
 60e:	dc 01       	movw	r26, r24
 610:	13 96       	adiw	r26, 0x03	; 3
 612:	3c 93       	st	X, r19
 614:	2e 93       	st	-X, r18
 616:	12 97       	sbiw	r26, 0x02	; 2
 618:	3d 83       	std	Y+5, r19	; 0x05
 61a:	2c 83       	std	Y+4, r18	; 0x04
 61c:	55 8b       	std	Z+21, r21	; 0x15
 61e:	44 8b       	std	Z+20, r20	; 0x14
 620:	da 01       	movw	r26, r20
 622:	8c 91       	ld	r24, X
 624:	8f 5f       	subi	r24, 0xFF	; 255
 626:	8c 93       	st	X, r24
 628:	96 89       	ldd	r25, Z+22	; 0x16
 62a:	e0 91 b5 06 	lds	r30, 0x06B5	; 0x8006b5 <pxCurrentTCB>
 62e:	f0 91 b6 06 	lds	r31, 0x06B6	; 0x8006b6 <pxCurrentTCB+0x1>
 632:	86 89       	ldd	r24, Z+22	; 0x16
 634:	89 17       	cp	r24, r25
 636:	20 f4       	brcc	.+8      	; 0x640 <xTaskRemoveFromEventList+0x17c>
 638:	81 e0       	ldi	r24, 0x01	; 1
 63a:	80 93 c4 06 	sts	0x06C4, r24	; 0x8006c4 <xYieldPending>
 63e:	01 c0       	rjmp	.+2      	; 0x642 <xTaskRemoveFromEventList+0x17e>
 640:	80 e0       	ldi	r24, 0x00	; 0
 642:	df 91       	pop	r29
 644:	cf 91       	pop	r28
 646:	08 95       	ret

Disassembly of section .text.vTaskInternalSetTimeOutState:

0000218a <vTaskInternalSetTimeOutState>:
    218a:	20 91 c3 06 	lds	r18, 0x06C3	; 0x8006c3 <xNumOfOverflows>
    218e:	fc 01       	movw	r30, r24
    2190:	20 83       	st	Z, r18
    2192:	20 91 af 06 	lds	r18, 0x06AF	; 0x8006af <xTickCount>
    2196:	30 91 b0 06 	lds	r19, 0x06B0	; 0x8006b0 <xTickCount+0x1>
    219a:	32 83       	std	Z+2, r19	; 0x02
    219c:	21 83       	std	Z+1, r18	; 0x01
    219e:	08 95       	ret

Disassembly of section .text.xTaskCheckForTimeOut:

00001786 <xTaskCheckForTimeOut>:
    1786:	1f 93       	push	r17
    1788:	cf 93       	push	r28
    178a:	df 93       	push	r29
    178c:	0f b6       	in	r0, 0x3f	; 63
    178e:	f8 94       	cli
    1790:	0f 92       	push	r0
    1792:	e0 91 af 06 	lds	r30, 0x06AF	; 0x8006af <xTickCount>
    1796:	f0 91 b0 06 	lds	r31, 0x06B0	; 0x8006b0 <xTickCount+0x1>
    179a:	dc 01       	movw	r26, r24
    179c:	11 96       	adiw	r26, 0x01	; 1
    179e:	4d 91       	ld	r20, X+
    17a0:	5c 91       	ld	r21, X
    17a2:	12 97       	sbiw	r26, 0x02	; 2
    17a4:	df 01       	movw	r26, r30
    17a6:	a4 1b       	sub	r26, r20
    17a8:	b5 0b       	sbc	r27, r21
    17aa:	eb 01       	movw	r28, r22
    17ac:	28 81       	ld	r18, Y
    17ae:	39 81       	ldd	r19, Y+1	; 0x01
    17b0:	2f 3f       	cpi	r18, 0xFF	; 255
    17b2:	df ef       	ldi	r29, 0xFF	; 255
    17b4:	3d 07       	cpc	r19, r29
    17b6:	f9 f0       	breq	.+62     	; 0x17f6 <xTaskCheckForTimeOut+0x70>
    17b8:	ec 01       	movw	r28, r24
    17ba:	18 81       	ld	r17, Y
    17bc:	c0 91 c3 06 	lds	r28, 0x06C3	; 0x8006c3 <xNumOfOverflows>
    17c0:	1c 17       	cp	r17, r28
    17c2:	41 f0       	breq	.+16     	; 0x17d4 <xTaskCheckForTimeOut+0x4e>
    17c4:	e4 17       	cp	r30, r20
    17c6:	f5 07       	cpc	r31, r21
    17c8:	28 f0       	brcs	.+10     	; 0x17d4 <xTaskCheckForTimeOut+0x4e>
    17ca:	fb 01       	movw	r30, r22
    17cc:	11 82       	std	Z+1, r1	; 0x01
    17ce:	10 82       	st	Z, r1
    17d0:	81 e0       	ldi	r24, 0x01	; 1
    17d2:	12 c0       	rjmp	.+36     	; 0x17f8 <xTaskCheckForTimeOut+0x72>
    17d4:	a2 17       	cp	r26, r18
    17d6:	b3 07       	cpc	r27, r19
    17d8:	48 f4       	brcc	.+18     	; 0x17ec <xTaskCheckForTimeOut+0x66>
    17da:	fb 01       	movw	r30, r22
    17dc:	2a 1b       	sub	r18, r26
    17de:	3b 0b       	sbc	r19, r27
    17e0:	31 83       	std	Z+1, r19	; 0x01
    17e2:	20 83       	st	Z, r18
    17e4:	0e 94 c5 10 	call	0x218a	; 0x218a <vTaskInternalSetTimeOutState>
    17e8:	80 e0       	ldi	r24, 0x00	; 0
    17ea:	06 c0       	rjmp	.+12     	; 0x17f8 <xTaskCheckForTimeOut+0x72>
    17ec:	db 01       	movw	r26, r22
    17ee:	1d 92       	st	X+, r1
    17f0:	1c 92       	st	X, r1
    17f2:	81 e0       	ldi	r24, 0x01	; 1
    17f4:	01 c0       	rjmp	.+2      	; 0x17f8 <xTaskCheckForTimeOut+0x72>
    17f6:	80 e0       	ldi	r24, 0x00	; 0
    17f8:	0f 90       	pop	r0
    17fa:	0f be       	out	0x3f, r0	; 63
    17fc:	df 91       	pop	r29
    17fe:	cf 91       	pop	r28
    1800:	1f 91       	pop	r17
    1802:	08 95       	ret

Disassembly of section .text.vTaskMissedYield:

00002222 <vTaskMissedYield>:
    2222:	81 e0       	ldi	r24, 0x01	; 1
    2224:	80 93 c4 06 	sts	0x06C4, r24	; 0x8006c4 <xYieldPending>
    2228:	08 95       	ret

Disassembly of section .text.xTaskGetSchedulerState:

00002154 <xTaskGetSchedulerState>:
    2154:	80 91 c5 06 	lds	r24, 0x06C5	; 0x8006c5 <xSchedulerRunning>
    2158:	88 23       	and	r24, r24
    215a:	31 f0       	breq	.+12     	; 0x2168 <xTaskGetSchedulerState+0x14>
    215c:	80 91 c1 06 	lds	r24, 0x06C1	; 0x8006c1 <uxSchedulerSuspended>
    2160:	81 11       	cpse	r24, r1
    2162:	04 c0       	rjmp	.+8      	; 0x216c <xTaskGetSchedulerState+0x18>
    2164:	82 e0       	ldi	r24, 0x02	; 2
    2166:	08 95       	ret
    2168:	81 e0       	ldi	r24, 0x01	; 1
    216a:	08 95       	ret
    216c:	80 e0       	ldi	r24, 0x00	; 0
    216e:	08 95       	ret

Disassembly of section .text.prvGetNextExpireTime:

00002060 <prvGetNextExpireTime>:
        }
    }
/*-----------------------------------------------------------*/

    static TickType_t prvGetNextExpireTime( BaseType_t * const pxListWasEmpty )
    {
    2060:	dc 01       	movw	r26, r24
         * the timer with the nearest expiry time will expire.  If there are no
         * active timers then just set the next expire time to 0.  That will cause
         * this task to unblock when the tick count overflows, at which point the
         * timer lists will be switched and the next expiry time can be
         * re-assessed.  */
        *pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
    2062:	e0 91 bf 06 	lds	r30, 0x06BF	; 0x8006bf <pxCurrentTimerList>
    2066:	f0 91 c0 06 	lds	r31, 0x06C0	; 0x8006c0 <pxCurrentTimerList+0x1>
    206a:	80 81       	ld	r24, Z
    206c:	91 e0       	ldi	r25, 0x01	; 1
    206e:	81 11       	cpse	r24, r1
    2070:	90 e0       	ldi	r25, 0x00	; 0
    2072:	9c 93       	st	X, r25

        if( *pxListWasEmpty == pdFALSE )
    2074:	91 11       	cpse	r25, r1
    2076:	06 c0       	rjmp	.+12     	; 0x2084 <prvGetNextExpireTime+0x24>
        {
            xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    2078:	05 80       	ldd	r0, Z+5	; 0x05
    207a:	f6 81       	ldd	r31, Z+6	; 0x06
    207c:	e0 2d       	mov	r30, r0
    207e:	80 81       	ld	r24, Z
    2080:	91 81       	ldd	r25, Z+1	; 0x01
    2082:	08 95       	ret
        }
        else
        {
            /* Ensure the task unblocks when the tick count rolls over. */
            xNextExpireTime = ( TickType_t ) 0U;
    2084:	80 e0       	ldi	r24, 0x00	; 0
    2086:	90 e0       	ldi	r25, 0x00	; 0
        }

        return xNextExpireTime;
    }
    2088:	08 95       	ret

Disassembly of section .text.prvInsertTimerInActiveList:

00001c20 <prvInsertTimerInActiveList>:

    static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer,
                                                  const TickType_t xNextExpiryTime,
                                                  const TickType_t xTimeNow,
                                                  const TickType_t xCommandTime )
    {
    1c20:	fc 01       	movw	r30, r24
        BaseType_t xProcessTimerNow = pdFALSE;

        listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
    1c22:	74 83       	std	Z+4, r23	; 0x04
    1c24:	63 83       	std	Z+3, r22	; 0x03
        listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    1c26:	92 87       	std	Z+10, r25	; 0x0a
    1c28:	81 87       	std	Z+9, r24	; 0x09

        if( xNextExpiryTime <= xTimeNow )
    1c2a:	46 17       	cp	r20, r22
    1c2c:	57 07       	cpc	r21, r23
    1c2e:	90 f0       	brcs	.+36     	; 0x1c54 <prvInsertTimerInActiveList+0x34>
        {
            /* Has the expiry time elapsed between the command to start/reset a
             * timer was issued, and the time the command was processed? */
            if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1c30:	42 1b       	sub	r20, r18
    1c32:	53 0b       	sbc	r21, r19
    1c34:	85 85       	ldd	r24, Z+13	; 0x0d
    1c36:	96 85       	ldd	r25, Z+14	; 0x0e
    1c38:	48 17       	cp	r20, r24
    1c3a:	59 07       	cpc	r21, r25
    1c3c:	e0 f4       	brcc	.+56     	; 0x1c76 <prvInsertTimerInActiveList+0x56>
                 * processed actually exceeds the timers period.  */
                xProcessTimerNow = pdTRUE;
            }
            else
            {
                vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
    1c3e:	bf 01       	movw	r22, r30
    1c40:	6d 5f       	subi	r22, 0xFD	; 253
    1c42:	7f 4f       	sbci	r23, 0xFF	; 255
    1c44:	80 91 bd 06 	lds	r24, 0x06BD	; 0x8006bd <pxOverflowTimerList>
    1c48:	90 91 be 06 	lds	r25, 0x06BE	; 0x8006be <pxOverflowTimerList+0x1>
    1c4c:	0e 94 7f 0d 	call	0x1afe	; 0x1afe <vListInsert>
    static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer,
                                                  const TickType_t xNextExpiryTime,
                                                  const TickType_t xTimeNow,
                                                  const TickType_t xCommandTime )
    {
        BaseType_t xProcessTimerNow = pdFALSE;
    1c50:	80 e0       	ldi	r24, 0x00	; 0
    1c52:	08 95       	ret
                vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
            }
        }
        else
        {
            if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
    1c54:	42 17       	cp	r20, r18
    1c56:	53 07       	cpc	r21, r19
    1c58:	18 f4       	brcc	.+6      	; 0x1c60 <prvInsertTimerInActiveList+0x40>
    1c5a:	62 17       	cp	r22, r18
    1c5c:	73 07       	cpc	r23, r19
    1c5e:	68 f4       	brcc	.+26     	; 0x1c7a <prvInsertTimerInActiveList+0x5a>
                 * its expiry time and should be processed immediately. */
                xProcessTimerNow = pdTRUE;
            }
            else
            {
                vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    1c60:	bf 01       	movw	r22, r30
    1c62:	6d 5f       	subi	r22, 0xFD	; 253
    1c64:	7f 4f       	sbci	r23, 0xFF	; 255
    1c66:	80 91 bf 06 	lds	r24, 0x06BF	; 0x8006bf <pxCurrentTimerList>
    1c6a:	90 91 c0 06 	lds	r25, 0x06C0	; 0x8006c0 <pxCurrentTimerList+0x1>
    1c6e:	0e 94 7f 0d 	call	0x1afe	; 0x1afe <vListInsert>
    static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer,
                                                  const TickType_t xNextExpiryTime,
                                                  const TickType_t xTimeNow,
                                                  const TickType_t xCommandTime )
    {
        BaseType_t xProcessTimerNow = pdFALSE;
    1c72:	80 e0       	ldi	r24, 0x00	; 0
    1c74:	08 95       	ret
             * timer was issued, and the time the command was processed? */
            if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
            {
                /* The time between a command being issued and the command being
                 * processed actually exceeds the timers period.  */
                xProcessTimerNow = pdTRUE;
    1c76:	81 e0       	ldi	r24, 0x01	; 1
    1c78:	08 95       	ret
            if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
            {
                /* If, since the command was issued, the tick count has overflowed
                 * but the expiry time has not, then the timer must have already passed
                 * its expiry time and should be processed immediately. */
                xProcessTimerNow = pdTRUE;
    1c7a:	81 e0       	ldi	r24, 0x01	; 1
                vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
            }
        }

        return xProcessTimerNow;
    }
    1c7c:	08 95       	ret

Disassembly of section .text.prvReloadTimer:

00001e14 <prvReloadTimer>:
/*-----------------------------------------------------------*/

    static void prvReloadTimer( Timer_t * const pxTimer,
                                TickType_t xExpiredTime,
                                const TickType_t xTimeNow )
    {
    1e14:	ef 92       	push	r14
    1e16:	ff 92       	push	r15
    1e18:	0f 93       	push	r16
    1e1a:	1f 93       	push	r17
    1e1c:	cf 93       	push	r28
    1e1e:	df 93       	push	r29
    1e20:	ec 01       	movw	r28, r24
    1e22:	8b 01       	movw	r16, r22
    1e24:	7a 01       	movw	r14, r20
        /* Insert the timer into the appropriate list for the next expiry time.
         * If the next expiry time has already passed, advance the expiry time,
         * call the callback function, and try again. */
        while( prvInsertTimerInActiveList( pxTimer, ( xExpiredTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xExpiredTime ) != pdFALSE )
    1e26:	08 c0       	rjmp	.+16     	; 0x1e38 <prvReloadTimer+0x24>
        {
            /* Advance the expiry time. */
            xExpiredTime += pxTimer->xTimerPeriodInTicks;
    1e28:	8d 85       	ldd	r24, Y+13	; 0x0d
    1e2a:	9e 85       	ldd	r25, Y+14	; 0x0e
    1e2c:	08 0f       	add	r16, r24
    1e2e:	19 1f       	adc	r17, r25

            /* Call the timer callback. */
            traceTIMER_EXPIRED( pxTimer );
            pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    1e30:	e9 89       	ldd	r30, Y+17	; 0x11
    1e32:	fa 89       	ldd	r31, Y+18	; 0x12
    1e34:	ce 01       	movw	r24, r28
    1e36:	09 95       	icall
                                const TickType_t xTimeNow )
    {
        /* Insert the timer into the appropriate list for the next expiry time.
         * If the next expiry time has already passed, advance the expiry time,
         * call the callback function, and try again. */
        while( prvInsertTimerInActiveList( pxTimer, ( xExpiredTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xExpiredTime ) != pdFALSE )
    1e38:	6d 85       	ldd	r22, Y+13	; 0x0d
    1e3a:	7e 85       	ldd	r23, Y+14	; 0x0e
    1e3c:	60 0f       	add	r22, r16
    1e3e:	71 1f       	adc	r23, r17
    1e40:	98 01       	movw	r18, r16
    1e42:	a7 01       	movw	r20, r14
    1e44:	ce 01       	movw	r24, r28
    1e46:	0e 94 10 0e 	call	0x1c20	; 0x1c20 <prvInsertTimerInActiveList>
    1e4a:	81 11       	cpse	r24, r1
    1e4c:	ed cf       	rjmp	.-38     	; 0x1e28 <prvReloadTimer+0x14>

            /* Call the timer callback. */
            traceTIMER_EXPIRED( pxTimer );
            pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
        }
    }
    1e4e:	df 91       	pop	r29
    1e50:	cf 91       	pop	r28
    1e52:	1f 91       	pop	r17
    1e54:	0f 91       	pop	r16
    1e56:	ff 90       	pop	r15
    1e58:	ef 90       	pop	r14
    1e5a:	08 95       	ret

Disassembly of section .text.prvProcessExpiredTimer:

00001c7e <prvProcessExpiredTimer>:
/*-----------------------------------------------------------*/

    static void prvProcessExpiredTimer( const TickType_t xNextExpireTime,
                                        const TickType_t xTimeNow )
    {
    1c7e:	ef 92       	push	r14
    1c80:	ff 92       	push	r15
    1c82:	0f 93       	push	r16
    1c84:	1f 93       	push	r17
    1c86:	cf 93       	push	r28
    1c88:	df 93       	push	r29
    1c8a:	8c 01       	movw	r16, r24
    1c8c:	7b 01       	movw	r14, r22
        Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    1c8e:	e0 91 bf 06 	lds	r30, 0x06BF	; 0x8006bf <pxCurrentTimerList>
    1c92:	f0 91 c0 06 	lds	r31, 0x06C0	; 0x8006c0 <pxCurrentTimerList+0x1>
    1c96:	05 80       	ldd	r0, Z+5	; 0x05
    1c98:	f6 81       	ldd	r31, Z+6	; 0x06
    1c9a:	e0 2d       	mov	r30, r0
    1c9c:	c6 81       	ldd	r28, Z+6	; 0x06
    1c9e:	d7 81       	ldd	r29, Z+7	; 0x07

        /* Remove the timer from the list of active timers.  A check has already
         * been performed to ensure the list is not empty. */

        ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    1ca0:	ce 01       	movw	r24, r28
    1ca2:	03 96       	adiw	r24, 0x03	; 3
    1ca4:	0e 94 bd 0e 	call	0x1d7a	; 0x1d7a <uxListRemove>

        /* If the timer is an auto-reload timer then calculate the next
         * expiry time and re-insert the timer in the list of active timers. */
        if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
    1ca8:	8b 89       	ldd	r24, Y+19	; 0x13
    1caa:	82 ff       	sbrs	r24, 2
    1cac:	06 c0       	rjmp	.+12     	; 0x1cba <prvProcessExpiredTimer+0x3c>
        {
            prvReloadTimer( pxTimer, xNextExpireTime, xTimeNow );
    1cae:	a7 01       	movw	r20, r14
    1cb0:	b8 01       	movw	r22, r16
    1cb2:	ce 01       	movw	r24, r28
    1cb4:	0e 94 0a 0f 	call	0x1e14	; 0x1e14 <prvReloadTimer>
    1cb8:	02 c0       	rjmp	.+4      	; 0x1cbe <prvProcessExpiredTimer+0x40>
        }
        else
        {
            pxTimer->ucStatus &= ( ( uint8_t ) ~tmrSTATUS_IS_ACTIVE );
    1cba:	8e 7f       	andi	r24, 0xFE	; 254
    1cbc:	8b 8b       	std	Y+19, r24	; 0x13
        }

        /* Call the timer callback. */
        traceTIMER_EXPIRED( pxTimer );
        pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    1cbe:	e9 89       	ldd	r30, Y+17	; 0x11
    1cc0:	fa 89       	ldd	r31, Y+18	; 0x12
    1cc2:	ce 01       	movw	r24, r28
    1cc4:	09 95       	icall
    }
    1cc6:	df 91       	pop	r29
    1cc8:	cf 91       	pop	r28
    1cca:	1f 91       	pop	r17
    1ccc:	0f 91       	pop	r16
    1cce:	ff 90       	pop	r15
    1cd0:	ef 90       	pop	r14
    1cd2:	08 95       	ret

Disassembly of section .text.prvSwitchTimerLists:

00001ee0 <prvSwitchTimerLists>:

        /* The tick count has overflowed.  The timer lists must be switched.
         * If there are any timers still referenced from the current timer list
         * then they must have expired and should be processed before the lists
         * are switched. */
        while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    1ee0:	09 c0       	rjmp	.+18     	; 0x1ef4 <prvSwitchTimerLists+0x14>
        {
            xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    1ee2:	05 80       	ldd	r0, Z+5	; 0x05
    1ee4:	f6 81       	ldd	r31, Z+6	; 0x06
    1ee6:	e0 2d       	mov	r30, r0

            /* Process the expired timer.  For auto-reload timers, be careful to
             * process only expirations that occur on the current list.  Further
             * expirations must wait until after the lists are switched. */
            prvProcessExpiredTimer( xNextExpireTime, tmrMAX_TIME_BEFORE_OVERFLOW );
    1ee8:	6f ef       	ldi	r22, 0xFF	; 255
    1eea:	7f ef       	ldi	r23, 0xFF	; 255
    1eec:	80 81       	ld	r24, Z
    1eee:	91 81       	ldd	r25, Z+1	; 0x01
    1ef0:	0e 94 3f 0e 	call	0x1c7e	; 0x1c7e <prvProcessExpiredTimer>

        /* The tick count has overflowed.  The timer lists must be switched.
         * If there are any timers still referenced from the current timer list
         * then they must have expired and should be processed before the lists
         * are switched. */
        while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    1ef4:	e0 91 bf 06 	lds	r30, 0x06BF	; 0x8006bf <pxCurrentTimerList>
    1ef8:	f0 91 c0 06 	lds	r31, 0x06C0	; 0x8006c0 <pxCurrentTimerList+0x1>
    1efc:	80 81       	ld	r24, Z
    1efe:	81 11       	cpse	r24, r1
    1f00:	f0 cf       	rjmp	.-32     	; 0x1ee2 <prvSwitchTimerLists+0x2>
             * expirations must wait until after the lists are switched. */
            prvProcessExpiredTimer( xNextExpireTime, tmrMAX_TIME_BEFORE_OVERFLOW );
        }

        pxTemp = pxCurrentTimerList;
        pxCurrentTimerList = pxOverflowTimerList;
    1f02:	80 91 bd 06 	lds	r24, 0x06BD	; 0x8006bd <pxOverflowTimerList>
    1f06:	90 91 be 06 	lds	r25, 0x06BE	; 0x8006be <pxOverflowTimerList+0x1>
    1f0a:	90 93 c0 06 	sts	0x06C0, r25	; 0x8006c0 <pxCurrentTimerList+0x1>
    1f0e:	80 93 bf 06 	sts	0x06BF, r24	; 0x8006bf <pxCurrentTimerList>
        pxOverflowTimerList = pxTemp;
    1f12:	f0 93 be 06 	sts	0x06BE, r31	; 0x8006be <pxOverflowTimerList+0x1>
    1f16:	e0 93 bd 06 	sts	0x06BD, r30	; 0x8006bd <pxOverflowTimerList>
    1f1a:	08 95       	ret

Disassembly of section .text.prvSampleTimeNow:

00001e9e <prvSampleTimeNow>:
        return xNextExpireTime;
    }
/*-----------------------------------------------------------*/

    static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
    {
    1e9e:	0f 93       	push	r16
    1ea0:	1f 93       	push	r17
    1ea2:	cf 93       	push	r28
    1ea4:	df 93       	push	r29
    1ea6:	8c 01       	movw	r16, r24
        TickType_t xTimeNow;
        PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

        xTimeNow = xTaskGetTickCount();
    1ea8:	0e 94 db 10 	call	0x21b6	; 0x21b6 <xTaskGetTickCount>
    1eac:	ec 01       	movw	r28, r24

        if( xTimeNow < xLastTime )
    1eae:	80 91 b7 06 	lds	r24, 0x06B7	; 0x8006b7 <xLastTime.2410>
    1eb2:	90 91 b8 06 	lds	r25, 0x06B8	; 0x8006b8 <xLastTime.2410+0x1>
    1eb6:	c8 17       	cp	r28, r24
    1eb8:	d9 07       	cpc	r29, r25
    1eba:	30 f4       	brcc	.+12     	; 0x1ec8 <prvSampleTimeNow+0x2a>
        {
            prvSwitchTimerLists();
    1ebc:	0e 94 70 0f 	call	0x1ee0	; 0x1ee0 <prvSwitchTimerLists>
            *pxTimerListsWereSwitched = pdTRUE;
    1ec0:	81 e0       	ldi	r24, 0x01	; 1
    1ec2:	f8 01       	movw	r30, r16
    1ec4:	80 83       	st	Z, r24
    1ec6:	02 c0       	rjmp	.+4      	; 0x1ecc <prvSampleTimeNow+0x2e>
        }
        else
        {
            *pxTimerListsWereSwitched = pdFALSE;
    1ec8:	f8 01       	movw	r30, r16
    1eca:	10 82       	st	Z, r1
        }

        xLastTime = xTimeNow;
    1ecc:	d0 93 b8 06 	sts	0x06B8, r29	; 0x8006b8 <xLastTime.2410+0x1>
    1ed0:	c0 93 b7 06 	sts	0x06B7, r28	; 0x8006b7 <xLastTime.2410>

        return xTimeNow;
    }
    1ed4:	ce 01       	movw	r24, r28
    1ed6:	df 91       	pop	r29
    1ed8:	cf 91       	pop	r28
    1eda:	1f 91       	pop	r17
    1edc:	0f 91       	pop	r16
    1ede:	08 95       	ret

Disassembly of section .text.prvProcessTimerOrBlockTask:

000015ea <prvProcessTimerOrBlockTask>:
    }
/*-----------------------------------------------------------*/

    static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime,
                                            BaseType_t xListWasEmpty )
    {
    15ea:	cf 92       	push	r12
    15ec:	df 92       	push	r13
    15ee:	ef 92       	push	r14
    15f0:	ff 92       	push	r15
    15f2:	1f 93       	push	r17
    15f4:	cf 93       	push	r28
    15f6:	df 93       	push	r29
    15f8:	0f 92       	push	r0
    15fa:	cd b7       	in	r28, 0x3d	; 61
    15fc:	de b7       	in	r29, 0x3e	; 62
    15fe:	7c 01       	movw	r14, r24
    1600:	16 2f       	mov	r17, r22
        TickType_t xTimeNow;
        BaseType_t xTimerListsWereSwitched;

        vTaskSuspendAll();
    1602:	0e 94 fc 10 	call	0x21f8	; 0x21f8 <vTaskSuspendAll>
            /* Obtain the time now to make an assessment as to whether the timer
             * has expired or not.  If obtaining the time causes the lists to switch
             * then don't process this timer as any timers that remained in the list
             * when the lists were switched will have been processed within the
             * prvSampleTimeNow() function. */
            xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    1606:	ce 01       	movw	r24, r28
    1608:	01 96       	adiw	r24, 0x01	; 1
    160a:	0e 94 4f 0f 	call	0x1e9e	; 0x1e9e <prvSampleTimeNow>
    160e:	6c 01       	movw	r12, r24

            if( xTimerListsWereSwitched == pdFALSE )
    1610:	89 81       	ldd	r24, Y+1	; 0x01
    1612:	81 11       	cpse	r24, r1
    1614:	27 c0       	rjmp	.+78     	; 0x1664 <prvProcessTimerOrBlockTask+0x7a>
            {
                /* The tick count has not overflowed, has the timer expired? */
                if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    1616:	11 11       	cpse	r17, r1
    1618:	0a c0       	rjmp	.+20     	; 0x162e <prvProcessTimerOrBlockTask+0x44>
    161a:	ce 14       	cp	r12, r14
    161c:	df 04       	cpc	r13, r15
    161e:	38 f0       	brcs	.+14     	; 0x162e <prvProcessTimerOrBlockTask+0x44>
                {
                    ( void ) xTaskResumeAll();
    1620:	0e 94 8d 01 	call	0x31a	; 0x31a <xTaskResumeAll>
                    prvProcessExpiredTimer( xNextExpireTime, xTimeNow );
    1624:	b6 01       	movw	r22, r12
    1626:	c7 01       	movw	r24, r14
    1628:	0e 94 3f 0e 	call	0x1c7e	; 0x1c7e <prvProcessExpiredTimer>
    162c:	1d c0       	rjmp	.+58     	; 0x1668 <prvProcessTimerOrBlockTask+0x7e>
                     * time has not been reached yet.  This task should therefore
                     * block to wait for the next expire time or a command to be
                     * received - whichever comes first.  The following line cannot
                     * be reached unless xNextExpireTime > xTimeNow, except in the
                     * case when the current timer list is empty. */
                    if( xListWasEmpty != pdFALSE )
    162e:	11 23       	and	r17, r17
    1630:	41 f0       	breq	.+16     	; 0x1642 <prvProcessTimerOrBlockTask+0x58>
                    {
                        /* The current timer list is empty - is the overflow list
                         * also empty? */
                        xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    1632:	e0 91 bd 06 	lds	r30, 0x06BD	; 0x8006bd <pxOverflowTimerList>
    1636:	f0 91 be 06 	lds	r31, 0x06BE	; 0x8006be <pxOverflowTimerList+0x1>
    163a:	80 81       	ld	r24, Z
    163c:	11 e0       	ldi	r17, 0x01	; 1
    163e:	81 11       	cpse	r24, r1
    1640:	10 e0       	ldi	r17, 0x00	; 0
                    }

                    vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
    1642:	b7 01       	movw	r22, r14
    1644:	6c 19       	sub	r22, r12
    1646:	7d 09       	sbc	r23, r13
    1648:	41 2f       	mov	r20, r17
    164a:	80 91 bb 06 	lds	r24, 0x06BB	; 0x8006bb <xTimerQueue>
    164e:	90 91 bc 06 	lds	r25, 0x06BC	; 0x8006bc <xTimerQueue+0x1>
    1652:	0e 94 8e 0f 	call	0x1f1c	; 0x1f1c <vQueueWaitForMessageRestricted>

                    if( xTaskResumeAll() == pdFALSE )
    1656:	0e 94 8d 01 	call	0x31a	; 0x31a <xTaskResumeAll>
    165a:	81 11       	cpse	r24, r1
    165c:	05 c0       	rjmp	.+10     	; 0x1668 <prvProcessTimerOrBlockTask+0x7e>
                    {
                        /* Yield to wait for either a command to arrive, or the
                         * block time to expire.  If a command arrived between the
                         * critical section being exited and this yield then the yield
                         * will not cause the task to block. */
                        portYIELD_WITHIN_API();
    165e:	0e 94 cb 08 	call	0x1196	; 0x1196 <vPortYield>
    1662:	02 c0       	rjmp	.+4      	; 0x1668 <prvProcessTimerOrBlockTask+0x7e>
                    }
                }
            }
            else
            {
                ( void ) xTaskResumeAll();
    1664:	0e 94 8d 01 	call	0x31a	; 0x31a <xTaskResumeAll>
            }
        }
    }
    1668:	0f 90       	pop	r0
    166a:	df 91       	pop	r29
    166c:	cf 91       	pop	r28
    166e:	1f 91       	pop	r17
    1670:	ff 90       	pop	r15
    1672:	ef 90       	pop	r14
    1674:	df 90       	pop	r13
    1676:	cf 90       	pop	r12
    1678:	08 95       	ret

Disassembly of section .text.prvProcessReceivedCommands:

0000079c <prvProcessReceivedCommands>:
        return xProcessTimerNow;
    }
/*-----------------------------------------------------------*/

    static void prvProcessReceivedCommands( void )
    {
 79c:	ef 92       	push	r14
 79e:	ff 92       	push	r15
 7a0:	0f 93       	push	r16
 7a2:	1f 93       	push	r17
 7a4:	cf 93       	push	r28
 7a6:	df 93       	push	r29
 7a8:	00 d0       	rcall	.+0      	; 0x7aa <prvProcessReceivedCommands+0xe>
 7aa:	00 d0       	rcall	.+0      	; 0x7ac <prvProcessReceivedCommands+0x10>
 7ac:	00 d0       	rcall	.+0      	; 0x7ae <prvProcessReceivedCommands+0x12>
 7ae:	cd b7       	in	r28, 0x3d	; 61
 7b0:	de b7       	in	r29, 0x3e	; 62
        DaemonTaskMessage_t xMessage;
        Timer_t * pxTimer;
        BaseType_t xTimerListsWereSwitched;
        TickType_t xTimeNow;

        while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
 7b2:	7a c0       	rjmp	.+244    	; 0x8a8 <__stack+0x49>
            }
            #endif /* INCLUDE_xTimerPendFunctionCall */

            /* Commands that are positive are timer commands rather than pended
             * function calls. */
            if( xMessage.xMessageID >= ( BaseType_t ) 0 )
 7b4:	89 81       	ldd	r24, Y+1	; 0x01
 7b6:	88 23       	and	r24, r24
 7b8:	0c f4       	brge	.+2      	; 0x7bc <prvProcessReceivedCommands+0x20>
 7ba:	76 c0       	rjmp	.+236    	; 0x8a8 <__stack+0x49>
            {
                /* The messages uses the xTimerParameters member to work on a
                 * software timer. */
                pxTimer = xMessage.u.xTimerParameters.pxTimer;
 7bc:	0c 81       	ldd	r16, Y+4	; 0x04
 7be:	1d 81       	ldd	r17, Y+5	; 0x05

                if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE ) /*lint !e961. The cast is only redundant when NULL is passed into the macro. */
 7c0:	d8 01       	movw	r26, r16
 7c2:	1b 96       	adiw	r26, 0x0b	; 11
 7c4:	8d 91       	ld	r24, X+
 7c6:	9c 91       	ld	r25, X
 7c8:	1c 97       	sbiw	r26, 0x0c	; 12
 7ca:	89 2b       	or	r24, r25
 7cc:	21 f0       	breq	.+8      	; 0x7d6 <prvProcessReceivedCommands+0x3a>
                {
                    /* The timer is in a list, remove it. */
                    ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
 7ce:	c8 01       	movw	r24, r16
 7d0:	03 96       	adiw	r24, 0x03	; 3
 7d2:	0e 94 bd 0e 	call	0x1d7a	; 0x1d7a <uxListRemove>
                 *  it must be present in the function call.  prvSampleTimeNow() must be
                 *  called after the message is received from xTimerQueue so there is no
                 *  possibility of a higher priority task adding a message to the message
                 *  queue with a time that is ahead of the timer daemon task (because it
                 *  pre-empted the timer daemon task after the xTimeNow value was set). */
                xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
 7d6:	ce 01       	movw	r24, r28
 7d8:	06 96       	adiw	r24, 0x06	; 6
 7da:	0e 94 4f 0f 	call	0x1e9e	; 0x1e9e <prvSampleTimeNow>
 7de:	7c 01       	movw	r14, r24

                switch( xMessage.xMessageID )
 7e0:	e9 81       	ldd	r30, Y+1	; 0x01
 7e2:	8e 2f       	mov	r24, r30
 7e4:	ee 0f       	add	r30, r30
 7e6:	99 0b       	sbc	r25, r25
 7e8:	aa 0b       	sbc	r26, r26
 7ea:	bb 0b       	sbc	r27, r27
 7ec:	fc 01       	movw	r30, r24
 7ee:	31 97       	sbiw	r30, 0x01	; 1
 7f0:	e9 30       	cpi	r30, 0x09	; 9
 7f2:	f1 05       	cpc	r31, r1
 7f4:	08 f0       	brcs	.+2      	; 0x7f8 <prvProcessReceivedCommands+0x5c>
 7f6:	58 c0       	rjmp	.+176    	; 0x8a8 <__stack+0x49>
 7f8:	e6 5d       	subi	r30, 0xD6	; 214
 7fa:	ff 4f       	sbci	r31, 0xFF	; 255
 7fc:	0c 94 02 11 	jmp	0x2204	; 0x2204 <__tablejump2__>
                    case tmrCOMMAND_START:
                    case tmrCOMMAND_START_FROM_ISR:
                    case tmrCOMMAND_RESET:
                    case tmrCOMMAND_RESET_FROM_ISR:
                        /* Start or restart a timer. */
                        pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
 800:	f8 01       	movw	r30, r16
 802:	83 89       	ldd	r24, Z+19	; 0x13
 804:	81 60       	ori	r24, 0x01	; 1
 806:	83 8b       	std	Z+19, r24	; 0x13

                        if( prvInsertTimerInActiveList( pxTimer, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
 808:	2a 81       	ldd	r18, Y+2	; 0x02
 80a:	3b 81       	ldd	r19, Y+3	; 0x03
 80c:	65 85       	ldd	r22, Z+13	; 0x0d
 80e:	76 85       	ldd	r23, Z+14	; 0x0e
 810:	62 0f       	add	r22, r18
 812:	73 1f       	adc	r23, r19
 814:	a7 01       	movw	r20, r14
 816:	c8 01       	movw	r24, r16
 818:	0e 94 10 0e 	call	0x1c20	; 0x1c20 <prvInsertTimerInActiveList>
 81c:	88 23       	and	r24, r24
 81e:	09 f4       	brne	.+2      	; 0x822 <__DATA_REGION_LENGTH__+0x22>
 820:	43 c0       	rjmp	.+134    	; 0x8a8 <__stack+0x49>
                        {
                            /* The timer expired before it was added to the active
                             * timer list.  Process it now. */
                            if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
 822:	d8 01       	movw	r26, r16
 824:	53 96       	adiw	r26, 0x13	; 19
 826:	8c 91       	ld	r24, X
 828:	53 97       	sbiw	r26, 0x13	; 19
 82a:	82 ff       	sbrs	r24, 2
 82c:	0d c0       	rjmp	.+26     	; 0x848 <__DATA_REGION_LENGTH__+0x48>
                            {
                                prvReloadTimer( pxTimer, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow );
 82e:	6a 81       	ldd	r22, Y+2	; 0x02
 830:	7b 81       	ldd	r23, Y+3	; 0x03
 832:	1d 96       	adiw	r26, 0x0d	; 13
 834:	8d 91       	ld	r24, X+
 836:	9c 91       	ld	r25, X
 838:	1e 97       	sbiw	r26, 0x0e	; 14
 83a:	68 0f       	add	r22, r24
 83c:	79 1f       	adc	r23, r25
 83e:	a7 01       	movw	r20, r14
 840:	c8 01       	movw	r24, r16
 842:	0e 94 0a 0f 	call	0x1e14	; 0x1e14 <prvReloadTimer>
 846:	03 c0       	rjmp	.+6      	; 0x84e <__DATA_REGION_LENGTH__+0x4e>
                            }
                            else
                            {
                                pxTimer->ucStatus &= ( ( uint8_t ) ~tmrSTATUS_IS_ACTIVE );
 848:	8e 7f       	andi	r24, 0xFE	; 254
 84a:	f8 01       	movw	r30, r16
 84c:	83 8b       	std	Z+19, r24	; 0x13
                            }

                            /* Call the timer callback. */
                            traceTIMER_EXPIRED( pxTimer );
                            pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
 84e:	d8 01       	movw	r26, r16
 850:	51 96       	adiw	r26, 0x11	; 17
 852:	ed 91       	ld	r30, X+
 854:	fc 91       	ld	r31, X
 856:	52 97       	sbiw	r26, 0x12	; 18
 858:	c8 01       	movw	r24, r16
 85a:	09 95       	icall
 85c:	25 c0       	rjmp	.+74     	; 0x8a8 <__stack+0x49>
                        break;

                    case tmrCOMMAND_STOP:
                    case tmrCOMMAND_STOP_FROM_ISR:
                        /* The timer has already been removed from the active list. */
                        pxTimer->ucStatus &= ( ( uint8_t ) ~tmrSTATUS_IS_ACTIVE );
 85e:	f8 01       	movw	r30, r16
 860:	83 89       	ldd	r24, Z+19	; 0x13
 862:	8e 7f       	andi	r24, 0xFE	; 254
 864:	83 8b       	std	Z+19, r24	; 0x13
                        break;
 866:	20 c0       	rjmp	.+64     	; 0x8a8 <__stack+0x49>

                    case tmrCOMMAND_CHANGE_PERIOD:
                    case tmrCOMMAND_CHANGE_PERIOD_FROM_ISR:
                        pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
 868:	d8 01       	movw	r26, r16
 86a:	53 96       	adiw	r26, 0x13	; 19
 86c:	8c 91       	ld	r24, X
 86e:	53 97       	sbiw	r26, 0x13	; 19
 870:	81 60       	ori	r24, 0x01	; 1
 872:	53 96       	adiw	r26, 0x13	; 19
 874:	8c 93       	st	X, r24
 876:	53 97       	sbiw	r26, 0x13	; 19
                        pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
 878:	6a 81       	ldd	r22, Y+2	; 0x02
 87a:	7b 81       	ldd	r23, Y+3	; 0x03
 87c:	1e 96       	adiw	r26, 0x0e	; 14
 87e:	7c 93       	st	X, r23
 880:	6e 93       	st	-X, r22
 882:	1d 97       	sbiw	r26, 0x0d	; 13
                         * be longer or shorter than the old one.  The command time is
                         * therefore set to the current time, and as the period cannot
                         * be zero the next expiry time can only be in the future,
                         * meaning (unlike for the xTimerStart() case above) there is
                         * no fail case that needs to be handled here. */
                        ( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
 884:	6e 0d       	add	r22, r14
 886:	7f 1d       	adc	r23, r15
 888:	97 01       	movw	r18, r14
 88a:	a7 01       	movw	r20, r14
 88c:	c8 01       	movw	r24, r16
 88e:	0e 94 10 0e 	call	0x1c20	; 0x1c20 <prvInsertTimerInActiveList>
                        break;
 892:	0a c0       	rjmp	.+20     	; 0x8a8 <__stack+0x49>
                        #if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
                        {
                            /* The timer has already been removed from the active list,
                             * just free up the memory if the memory was dynamically
                             * allocated. */
                            if( ( pxTimer->ucStatus & tmrSTATUS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) 0 )
 894:	f8 01       	movw	r30, r16
 896:	83 89       	ldd	r24, Z+19	; 0x13
 898:	81 fd       	sbrc	r24, 1
 89a:	04 c0       	rjmp	.+8      	; 0x8a4 <__stack+0x45>
                            {
                                vPortFree( pxTimer );
 89c:	c8 01       	movw	r24, r16
 89e:	0e 94 22 11 	call	0x2244	; 0x2244 <vPortFree>
 8a2:	02 c0       	rjmp	.+4      	; 0x8a8 <__stack+0x49>
                            }
                            else
                            {
                                pxTimer->ucStatus &= ( ( uint8_t ) ~tmrSTATUS_IS_ACTIVE );
 8a4:	8e 7f       	andi	r24, 0xFE	; 254
 8a6:	83 8b       	std	Z+19, r24	; 0x13
        DaemonTaskMessage_t xMessage;
        Timer_t * pxTimer;
        BaseType_t xTimerListsWereSwitched;
        TickType_t xTimeNow;

        while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
 8a8:	40 e0       	ldi	r20, 0x00	; 0
 8aa:	50 e0       	ldi	r21, 0x00	; 0
 8ac:	be 01       	movw	r22, r28
 8ae:	6f 5f       	subi	r22, 0xFF	; 255
 8b0:	7f 4f       	sbci	r23, 0xFF	; 255
 8b2:	80 91 bb 06 	lds	r24, 0x06BB	; 0x8006bb <xTimerQueue>
 8b6:	90 91 bc 06 	lds	r25, 0x06BC	; 0x8006bc <xTimerQueue+0x1>
 8ba:	0e 94 6e 04 	call	0x8dc	; 0x8dc <xQueueReceive>
 8be:	81 11       	cpse	r24, r1
 8c0:	79 cf       	rjmp	.-270    	; 0x7b4 <prvProcessReceivedCommands+0x18>
                        /* Don't expect to get here. */
                        break;
                }
            }
        }
    }
 8c2:	26 96       	adiw	r28, 0x06	; 6
 8c4:	0f b6       	in	r0, 0x3f	; 63
 8c6:	f8 94       	cli
 8c8:	de bf       	out	0x3e, r29	; 62
 8ca:	0f be       	out	0x3f, r0	; 63
 8cc:	cd bf       	out	0x3d, r28	; 61
 8ce:	df 91       	pop	r29
 8d0:	cf 91       	pop	r28
 8d2:	1f 91       	pop	r17
 8d4:	0f 91       	pop	r16
 8d6:	ff 90       	pop	r15
 8d8:	ef 90       	pop	r14
 8da:	08 95       	ret

Disassembly of section .text.prvTimerTask:

000020fc <prvTimerTask>:
        pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    }
/*-----------------------------------------------------------*/

    static portTASK_FUNCTION( prvTimerTask, pvParameters )
    {
    20fc:	cf 93       	push	r28
    20fe:	df 93       	push	r29
    2100:	0f 92       	push	r0
    2102:	cd b7       	in	r28, 0x3d	; 61
    2104:	de b7       	in	r29, 0x3e	; 62

        for( ; ; )
        {
            /* Query the timers list to see if it contains any timers, and if so,
             * obtain the time at which the next timer will expire. */
            xNextExpireTime = prvGetNextExpireTime( &xListWasEmpty );
    2106:	ce 01       	movw	r24, r28
    2108:	01 96       	adiw	r24, 0x01	; 1
    210a:	0e 94 30 10 	call	0x2060	; 0x2060 <prvGetNextExpireTime>

            /* If a timer has expired, process it.  Otherwise, block this task
             * until either a timer does expire, or a command is received. */
            prvProcessTimerOrBlockTask( xNextExpireTime, xListWasEmpty );
    210e:	69 81       	ldd	r22, Y+1	; 0x01
    2110:	0e 94 f5 0a 	call	0x15ea	; 0x15ea <prvProcessTimerOrBlockTask>

            /* Empty the command queue. */
            prvProcessReceivedCommands();
    2114:	0e 94 ce 03 	call	0x79c	; 0x79c <prvProcessReceivedCommands>
    2118:	f6 cf       	rjmp	.-20     	; 0x2106 <prvTimerTask+0xa>

Disassembly of section .text.prvCheckForValidListAndQueue:

00001d28 <prvCheckForValidListAndQueue>:
    static void prvCheckForValidListAndQueue( void )
    {
        /* Check that the list from which active timers are referenced, and the
         * queue used to communicate with the timer service, have been
         * initialised. */
        taskENTER_CRITICAL();
    1d28:	0f b6       	in	r0, 0x3f	; 63
    1d2a:	f8 94       	cli
    1d2c:	0f 92       	push	r0
        {
            if( xTimerQueue == NULL )
    1d2e:	80 91 bb 06 	lds	r24, 0x06BB	; 0x8006bb <xTimerQueue>
    1d32:	90 91 bc 06 	lds	r25, 0x06BC	; 0x8006bc <xTimerQueue+0x1>
    1d36:	89 2b       	or	r24, r25
    1d38:	e9 f4       	brne	.+58     	; 0x1d74 <prvCheckForValidListAndQueue+0x4c>
            {
                vListInitialise( &xActiveTimerList1 );
    1d3a:	8c e9       	ldi	r24, 0x9C	; 156
    1d3c:	96 e0       	ldi	r25, 0x06	; 6
    1d3e:	0e 94 9c 10 	call	0x2138	; 0x2138 <vListInitialise>
                vListInitialise( &xActiveTimerList2 );
    1d42:	83 e9       	ldi	r24, 0x93	; 147
    1d44:	96 e0       	ldi	r25, 0x06	; 6
    1d46:	0e 94 9c 10 	call	0x2138	; 0x2138 <vListInitialise>
                pxCurrentTimerList = &xActiveTimerList1;
    1d4a:	8c e9       	ldi	r24, 0x9C	; 156
    1d4c:	96 e0       	ldi	r25, 0x06	; 6
    1d4e:	90 93 c0 06 	sts	0x06C0, r25	; 0x8006c0 <pxCurrentTimerList+0x1>
    1d52:	80 93 bf 06 	sts	0x06BF, r24	; 0x8006bf <pxCurrentTimerList>
                pxOverflowTimerList = &xActiveTimerList2;
    1d56:	83 e9       	ldi	r24, 0x93	; 147
    1d58:	96 e0       	ldi	r25, 0x06	; 6
    1d5a:	90 93 be 06 	sts	0x06BE, r25	; 0x8006be <pxOverflowTimerList+0x1>
    1d5e:	80 93 bd 06 	sts	0x06BD, r24	; 0x8006bd <pxOverflowTimerList>

                    xTimerQueue = xQueueCreateStatic( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, ( UBaseType_t ) sizeof( DaemonTaskMessage_t ), &( ucStaticTimerQueueStorage[ 0 ] ), &xStaticTimerQueue );
                }
                #else
                {
                    xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ) );
    1d62:	40 e0       	ldi	r20, 0x00	; 0
    1d64:	65 e0       	ldi	r22, 0x05	; 5
    1d66:	8a e0       	ldi	r24, 0x0A	; 10
    1d68:	0e 94 82 0b 	call	0x1704	; 0x1704 <xQueueGenericCreate>
    1d6c:	90 93 bc 06 	sts	0x06BC, r25	; 0x8006bc <xTimerQueue+0x1>
    1d70:	80 93 bb 06 	sts	0x06BB, r24	; 0x8006bb <xTimerQueue>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    1d74:	0f 90       	pop	r0
    1d76:	0f be       	out	0x3f, r0	; 63
    1d78:	08 95       	ret

Disassembly of section .text.prvInitialiseNewTimer:

0000195c <prvInitialiseNewTimer>:
                                       const TickType_t xTimerPeriodInTicks,
                                       const BaseType_t xAutoReload,
                                       void * const pvTimerID,
                                       TimerCallbackFunction_t pxCallbackFunction,
                                       Timer_t * pxNewTimer )
    {
    195c:	4f 92       	push	r4
    195e:	5f 92       	push	r5
    1960:	6f 92       	push	r6
    1962:	7f 92       	push	r7
    1964:	8f 92       	push	r8
    1966:	bf 92       	push	r11
    1968:	cf 92       	push	r12
    196a:	df 92       	push	r13
    196c:	ef 92       	push	r14
    196e:	ff 92       	push	r15
    1970:	0f 93       	push	r16
    1972:	1f 93       	push	r17
    1974:	cf 93       	push	r28
    1976:	df 93       	push	r29
    1978:	3b 01       	movw	r6, r22
    197a:	88 2e       	mov	r8, r24
    197c:	2a 01       	movw	r4, r20
    197e:	b2 2e       	mov	r11, r18
    1980:	e6 01       	movw	r28, r12
        /* 0 is not a valid value for xTimerPeriodInTicks. */
        configASSERT( ( xTimerPeriodInTicks > 0 ) );

        /* Ensure the infrastructure used by the timer service task has been
         * created/initialised. */
        prvCheckForValidListAndQueue();
    1982:	0e 94 94 0e 	call	0x1d28	; 0x1d28 <prvCheckForValidListAndQueue>

        /* Initialise the timer structure members using the function
         * parameters. */
        pxNewTimer->pcTimerName = pcTimerName;
    1986:	68 82       	st	Y, r6
    1988:	79 82       	std	Y+1, r7	; 0x01
    198a:	8a 82       	std	Y+2, r8	; 0x02
        pxNewTimer->xTimerPeriodInTicks = xTimerPeriodInTicks;
    198c:	5e 86       	std	Y+14, r5	; 0x0e
    198e:	4d 86       	std	Y+13, r4	; 0x0d
        pxNewTimer->pvTimerID = pvTimerID;
    1990:	18 8b       	std	Y+16, r17	; 0x10
    1992:	0f 87       	std	Y+15, r16	; 0x0f
        pxNewTimer->pxCallbackFunction = pxCallbackFunction;
    1994:	fa 8a       	std	Y+18, r15	; 0x12
    1996:	e9 8a       	std	Y+17, r14	; 0x11
        vListInitialiseItem( &( pxNewTimer->xTimerListItem ) );
    1998:	c6 01       	movw	r24, r12
    199a:	03 96       	adiw	r24, 0x03	; 3
    199c:	0e 94 0d 11 	call	0x221a	; 0x221a <vListInitialiseItem>

        if( xAutoReload != pdFALSE )
    19a0:	bb 20       	and	r11, r11
    19a2:	19 f0       	breq	.+6      	; 0x19aa <prvInitialiseNewTimer+0x4e>
        {
            pxNewTimer->ucStatus |= tmrSTATUS_IS_AUTORELOAD;
    19a4:	8b 89       	ldd	r24, Y+19	; 0x13
    19a6:	84 60       	ori	r24, 0x04	; 4
    19a8:	8b 8b       	std	Y+19, r24	; 0x13
        }

        traceTIMER_CREATE( pxNewTimer );
    }
    19aa:	df 91       	pop	r29
    19ac:	cf 91       	pop	r28
    19ae:	1f 91       	pop	r17
    19b0:	0f 91       	pop	r16
    19b2:	ff 90       	pop	r15
    19b4:	ef 90       	pop	r14
    19b6:	df 90       	pop	r13
    19b8:	cf 90       	pop	r12
    19ba:	bf 90       	pop	r11
    19bc:	8f 90       	pop	r8
    19be:	7f 90       	pop	r7
    19c0:	6f 90       	pop	r6
    19c2:	5f 90       	pop	r5
    19c4:	4f 90       	pop	r4
    19c6:	08 95       	ret

Disassembly of section .text.xTimerCreateTimerTask:

00001cd4 <xTimerCreateTimerTask>:
                                       TimerCallbackFunction_t pxCallbackFunction,
                                       Timer_t * pxNewTimer ) PRIVILEGED_FUNCTION;
/*-----------------------------------------------------------*/

    BaseType_t xTimerCreateTimerTask( void )
    {
    1cd4:	cf 92       	push	r12
    1cd6:	df 92       	push	r13
    1cd8:	ef 92       	push	r14
    1cda:	0f 93       	push	r16
    1cdc:	1f 93       	push	r17

        /* This function is called when the scheduler is started if
         * configUSE_TIMERS is set to 1.  Check that the infrastructure used by the
         * timer service task has been created/initialised.  If timers have already
         * been created then the initialisation will already have been performed. */
        prvCheckForValidListAndQueue();
    1cde:	0e 94 94 0e 	call	0x1d28	; 0x1d28 <prvCheckForValidListAndQueue>

        if( xTimerQueue != NULL )
    1ce2:	80 91 bb 06 	lds	r24, 0x06BB	; 0x8006bb <xTimerQueue>
    1ce6:	90 91 bc 06 	lds	r25, 0x06BC	; 0x8006bc <xTimerQueue+0x1>
    1cea:	89 2b       	or	r24, r25
    1cec:	b1 f0       	breq	.+44     	; 0x1d1a <xTimerCreateTimerTask+0x46>
                    xReturn = pdPASS;
                }
            }
            #else /* if ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
            {
                xReturn = xTaskCreate( prvTimerTask,
    1cee:	0f 2e       	mov	r0, r31
    1cf0:	f9 eb       	ldi	r31, 0xB9	; 185
    1cf2:	cf 2e       	mov	r12, r31
    1cf4:	f6 e0       	ldi	r31, 0x06	; 6
    1cf6:	df 2e       	mov	r13, r31
    1cf8:	f0 2d       	mov	r31, r0
    1cfa:	0f 2e       	mov	r0, r31
    1cfc:	f3 e0       	ldi	r31, 0x03	; 3
    1cfe:	ef 2e       	mov	r14, r31
    1d00:	f0 2d       	mov	r31, r0
    1d02:	00 e0       	ldi	r16, 0x00	; 0
    1d04:	10 e0       	ldi	r17, 0x00	; 0
    1d06:	25 e5       	ldi	r18, 0x55	; 85
    1d08:	30 e0       	ldi	r19, 0x00	; 0
    1d0a:	47 ed       	ldi	r20, 0xD7	; 215
    1d0c:	50 e0       	ldi	r21, 0x00	; 0
    1d0e:	60 e0       	ldi	r22, 0x00	; 0
    1d10:	8e e7       	ldi	r24, 0x7E	; 126
    1d12:	90 e1       	ldi	r25, 0x10	; 16
    1d14:	0e 94 74 06 	call	0xce8	; 0xce8 <xTaskCreate>
    1d18:	01 c0       	rjmp	.+2      	; 0x1d1c <xTimerCreateTimerTask+0x48>
                                       Timer_t * pxNewTimer ) PRIVILEGED_FUNCTION;
/*-----------------------------------------------------------*/

    BaseType_t xTimerCreateTimerTask( void )
    {
        BaseType_t xReturn = pdFAIL;
    1d1a:	80 e0       	ldi	r24, 0x00	; 0
            mtCOVERAGE_TEST_MARKER();
        }

        configASSERT( xReturn );
        return xReturn;
    }
    1d1c:	1f 91       	pop	r17
    1d1e:	0f 91       	pop	r16
    1d20:	ef 90       	pop	r14
    1d22:	df 90       	pop	r13
    1d24:	cf 90       	pop	r12
    1d26:	08 95       	ret

Disassembly of section .text.xTimerCreate:

00001b60 <xTimerCreate>:
        TimerHandle_t xTimerCreate( const char * const pcTimerName, /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
                                    const TickType_t xTimerPeriodInTicks,
                                    const BaseType_t xAutoReload,
                                    void * const pvTimerID,
                                    TimerCallbackFunction_t pxCallbackFunction )
        {
    1b60:	6f 92       	push	r6
    1b62:	7f 92       	push	r7
    1b64:	8f 92       	push	r8
    1b66:	9f 92       	push	r9
    1b68:	af 92       	push	r10
    1b6a:	bf 92       	push	r11
    1b6c:	cf 92       	push	r12
    1b6e:	df 92       	push	r13
    1b70:	ef 92       	push	r14
    1b72:	ff 92       	push	r15
    1b74:	0f 93       	push	r16
    1b76:	1f 93       	push	r17
    1b78:	cf 93       	push	r28
    1b7a:	df 93       	push	r29
    1b7c:	3b 01       	movw	r6, r22
    1b7e:	88 2e       	mov	r8, r24
    1b80:	5a 01       	movw	r10, r20
    1b82:	92 2e       	mov	r9, r18
            Timer_t * pxNewTimer;

            pxNewTimer = ( Timer_t * ) pvPortMalloc( sizeof( Timer_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of Timer_t is always a pointer to the timer's mame. */
    1b84:	84 e1       	ldi	r24, 0x14	; 20
    1b86:	90 e0       	ldi	r25, 0x00	; 0
    1b88:	0e 94 3d 0c 	call	0x187a	; 0x187a <pvPortMalloc>
    1b8c:	ec 01       	movw	r28, r24

            if( pxNewTimer != NULL )
    1b8e:	00 97       	sbiw	r24, 0x00	; 0
    1b90:	41 f0       	breq	.+16     	; 0x1ba2 <xTimerCreate+0x42>
            {
                /* Status is thus far zero as the timer is not created statically
                 * and has not been started.  The auto-reload bit may get set in
                 * prvInitialiseNewTimer. */
                pxNewTimer->ucStatus = 0x00;
    1b92:	1b 8a       	std	Y+19, r1	; 0x13
                prvInitialiseNewTimer( pcTimerName, xTimerPeriodInTicks, xAutoReload, pvTimerID, pxCallbackFunction, pxNewTimer );
    1b94:	6c 01       	movw	r12, r24
    1b96:	29 2d       	mov	r18, r9
    1b98:	a5 01       	movw	r20, r10
    1b9a:	88 2d       	mov	r24, r8
    1b9c:	b3 01       	movw	r22, r6
    1b9e:	0e 94 ae 0c 	call	0x195c	; 0x195c <prvInitialiseNewTimer>
            }

            return pxNewTimer;
        }
    1ba2:	ce 01       	movw	r24, r28
    1ba4:	df 91       	pop	r29
    1ba6:	cf 91       	pop	r28
    1ba8:	1f 91       	pop	r17
    1baa:	0f 91       	pop	r16
    1bac:	ff 90       	pop	r15
    1bae:	ef 90       	pop	r14
    1bb0:	df 90       	pop	r13
    1bb2:	cf 90       	pop	r12
    1bb4:	bf 90       	pop	r11
    1bb6:	af 90       	pop	r10
    1bb8:	9f 90       	pop	r9
    1bba:	8f 90       	pop	r8
    1bbc:	7f 90       	pop	r7
    1bbe:	6f 90       	pop	r6
    1bc0:	08 95       	ret

Disassembly of section .text.xTimerGenericCommand:

00001392 <xTimerGenericCommand>:
    BaseType_t xTimerGenericCommand( TimerHandle_t xTimer,
                                     const BaseType_t xCommandID,
                                     const TickType_t xOptionalValue,
                                     BaseType_t * const pxHigherPriorityTaskWoken,
                                     const TickType_t xTicksToWait )
    {
    1392:	ef 92       	push	r14
    1394:	ff 92       	push	r15
    1396:	0f 93       	push	r16
    1398:	1f 93       	push	r17
    139a:	cf 93       	push	r28
    139c:	df 93       	push	r29
    139e:	00 d0       	rcall	.+0      	; 0x13a0 <xTimerGenericCommand+0xe>
    13a0:	00 d0       	rcall	.+0      	; 0x13a2 <xTimerGenericCommand+0x10>
    13a2:	0f 92       	push	r0
    13a4:	cd b7       	in	r28, 0x3d	; 61
    13a6:	de b7       	in	r29, 0x3e	; 62

        configASSERT( xTimer );

        /* Send a message to the timer service task to perform a particular action
         * on a particular timer definition. */
        if( xTimerQueue != NULL )
    13a8:	e0 91 bb 06 	lds	r30, 0x06BB	; 0x8006bb <xTimerQueue>
    13ac:	f0 91 bc 06 	lds	r31, 0x06BC	; 0x8006bc <xTimerQueue+0x1>
    13b0:	30 97       	sbiw	r30, 0x00	; 0
    13b2:	81 f1       	breq	.+96     	; 0x1414 <xTimerGenericCommand+0x82>
    13b4:	78 01       	movw	r14, r16
        {
            /* Send a command to the timer service task to start the xTimer timer. */
            xMessage.xMessageID = xCommandID;
    13b6:	69 83       	std	Y+1, r22	; 0x01
            xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
    13b8:	5b 83       	std	Y+3, r21	; 0x03
    13ba:	4a 83       	std	Y+2, r20	; 0x02
            xMessage.u.xTimerParameters.pxTimer = xTimer;
    13bc:	9d 83       	std	Y+5, r25	; 0x05
    13be:	8c 83       	std	Y+4, r24	; 0x04

            if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
    13c0:	66 30       	cpi	r22, 0x06	; 6
    13c2:	fc f4       	brge	.+62     	; 0x1402 <xTimerGenericCommand+0x70>
            {
                if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
    13c4:	0e 94 aa 10 	call	0x2154	; 0x2154 <xTaskGetSchedulerState>
    13c8:	82 30       	cpi	r24, 0x02	; 2
    13ca:	69 f4       	brne	.+26     	; 0x13e6 <xTimerGenericCommand+0x54>
                {
                    xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
    13cc:	ae 01       	movw	r20, r28
    13ce:	4f 5f       	subi	r20, 0xFF	; 255
    13d0:	5f 4f       	sbci	r21, 0xFF	; 255
    13d2:	60 e8       	ldi	r22, 0x80	; 128
    13d4:	00 e0       	ldi	r16, 0x00	; 0
    13d6:	97 01       	movw	r18, r14
    13d8:	80 91 bb 06 	lds	r24, 0x06BB	; 0x8006bb <xTimerQueue>
    13dc:	90 91 bc 06 	lds	r25, 0x06BC	; 0x8006bc <xTimerQueue+0x1>
    13e0:	0e 94 24 03 	call	0x648	; 0x648 <xQueueGenericSend>
    13e4:	18 c0       	rjmp	.+48     	; 0x1416 <xTimerGenericCommand+0x84>
                }
                else
                {
                    xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
    13e6:	ae 01       	movw	r20, r28
    13e8:	4f 5f       	subi	r20, 0xFF	; 255
    13ea:	5f 4f       	sbci	r21, 0xFF	; 255
    13ec:	60 e8       	ldi	r22, 0x80	; 128
    13ee:	00 e0       	ldi	r16, 0x00	; 0
    13f0:	20 e0       	ldi	r18, 0x00	; 0
    13f2:	30 e0       	ldi	r19, 0x00	; 0
    13f4:	80 91 bb 06 	lds	r24, 0x06BB	; 0x8006bb <xTimerQueue>
    13f8:	90 91 bc 06 	lds	r25, 0x06BC	; 0x8006bc <xTimerQueue+0x1>
    13fc:	0e 94 24 03 	call	0x648	; 0x648 <xQueueGenericSend>
    1400:	0a c0       	rjmp	.+20     	; 0x1416 <xTimerGenericCommand+0x84>
                }
            }
            else
            {
                xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
    1402:	ae 01       	movw	r20, r28
    1404:	4f 5f       	subi	r20, 0xFF	; 255
    1406:	5f 4f       	sbci	r21, 0xFF	; 255
    1408:	60 e8       	ldi	r22, 0x80	; 128
    140a:	00 e0       	ldi	r16, 0x00	; 0
    140c:	cf 01       	movw	r24, r30
    140e:	0e 94 11 08 	call	0x1022	; 0x1022 <xQueueGenericSendFromISR>
    1412:	01 c0       	rjmp	.+2      	; 0x1416 <xTimerGenericCommand+0x84>
                                     const BaseType_t xCommandID,
                                     const TickType_t xOptionalValue,
                                     BaseType_t * const pxHigherPriorityTaskWoken,
                                     const TickType_t xTicksToWait )
    {
        BaseType_t xReturn = pdFAIL;
    1414:	80 e0       	ldi	r24, 0x00	; 0
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xReturn;
    }
    1416:	0f 90       	pop	r0
    1418:	0f 90       	pop	r0
    141a:	0f 90       	pop	r0
    141c:	0f 90       	pop	r0
    141e:	0f 90       	pop	r0
    1420:	df 91       	pop	r29
    1422:	cf 91       	pop	r28
    1424:	1f 91       	pop	r17
    1426:	0f 91       	pop	r16
    1428:	ff 90       	pop	r15
    142a:	ef 90       	pop	r14
    142c:	08 95       	ret

Disassembly of section .text.libgcc.div:

0000208a <__udivmodhi4>:
    208a:	aa 1b       	sub	r26, r26
    208c:	bb 1b       	sub	r27, r27
    208e:	51 e1       	ldi	r21, 0x11	; 17
    2090:	07 c0       	rjmp	.+14     	; 0x20a0 <__udivmodhi4_ep>

00002092 <__udivmodhi4_loop>:
    2092:	aa 1f       	adc	r26, r26
    2094:	bb 1f       	adc	r27, r27
    2096:	a6 17       	cp	r26, r22
    2098:	b7 07       	cpc	r27, r23
    209a:	10 f0       	brcs	.+4      	; 0x20a0 <__udivmodhi4_ep>
    209c:	a6 1b       	sub	r26, r22
    209e:	b7 0b       	sbc	r27, r23

000020a0 <__udivmodhi4_ep>:
    20a0:	88 1f       	adc	r24, r24
    20a2:	99 1f       	adc	r25, r25
    20a4:	5a 95       	dec	r21
    20a6:	a9 f7       	brne	.-22     	; 0x2092 <__udivmodhi4_loop>
    20a8:	80 95       	com	r24
    20aa:	90 95       	com	r25
    20ac:	bc 01       	movw	r22, r24
    20ae:	cd 01       	movw	r24, r26
    20b0:	08 95       	ret

Disassembly of section .text.libgcc:

00002204 <__tablejump2__>:
    2204:	ee 0f       	add	r30, r30
    2206:	ff 1f       	adc	r31, r31
    2208:	05 90       	lpm	r0, Z+
    220a:	f4 91       	lpm	r31, Z
    220c:	e0 2d       	mov	r30, r0
    220e:	09 94       	ijmp

Disassembly of section .text.libgcc.mul:

0000211a <__umulhisi3>:
    211a:	a2 9f       	mul	r26, r18
    211c:	b0 01       	movw	r22, r0
    211e:	b3 9f       	mul	r27, r19
    2120:	c0 01       	movw	r24, r0
    2122:	a3 9f       	mul	r26, r19
    2124:	70 0d       	add	r23, r0
    2126:	81 1d       	adc	r24, r1
    2128:	11 24       	eor	r1, r1
    212a:	91 1d       	adc	r25, r1
    212c:	b2 9f       	mul	r27, r18
    212e:	70 0d       	add	r23, r0
    2130:	81 1d       	adc	r24, r1
    2132:	11 24       	eor	r1, r1
    2134:	91 1d       	adc	r25, r1
    2136:	08 95       	ret

Disassembly of section .text.libgcc:

000021dc <__xload_2>:
    21dc:	57 fd       	sbrc	r21, 7
    21de:	03 c0       	rjmp	.+6      	; 0x21e6 <__xload_2+0xa>
    21e0:	65 91       	lpm	r22, Z+
    21e2:	75 91       	lpm	r23, Z+
    21e4:	08 95       	ret
    21e6:	61 91       	ld	r22, Z+
    21e8:	71 91       	ld	r23, Z+
    21ea:	08 95       	ret

Disassembly of section .text.__dummy_fini:

00002246 <_fini>:
    2246:	08 95       	ret

Disassembly of section .text.__dummy_funcs_on_exit:

00002248 <__funcs_on_exit>:
    2248:	08 95       	ret

Disassembly of section .text.__dummy_simulator_exit:

0000224a <__simulator_exit>:
    224a:	08 95       	ret

Disassembly of section .text.exit:

000021a0 <exit>:
    21a0:	ec 01       	movw	r28, r24
    21a2:	0e 94 24 11 	call	0x2248	; 0x2248 <__funcs_on_exit>
    21a6:	0e 94 23 11 	call	0x2246	; 0x2246 <_fini>
    21aa:	ce 01       	movw	r24, r28
    21ac:	0e 94 25 11 	call	0x224a	; 0x224a <__simulator_exit>
    21b0:	ce 01       	movw	r24, r28
    21b2:	0e 94 20 11 	call	0x2240	; 0x2240 <_Exit>

Disassembly of section .text.memcpy:

0000202e <memcpy>:
    202e:	cf 92       	push	r12
    2030:	df 92       	push	r13
    2032:	ef 92       	push	r14
    2034:	6a 01       	movw	r12, r20
    2036:	e6 2e       	mov	r14, r22
    2038:	dc 01       	movw	r26, r24
    203a:	28 0f       	add	r18, r24
    203c:	39 1f       	adc	r19, r25
    203e:	a2 17       	cp	r26, r18
    2040:	b3 07       	cpc	r27, r19
    2042:	51 f0       	breq	.+20     	; 0x2058 <memcpy+0x2a>
    2044:	f6 01       	movw	r30, r12
    2046:	44 91       	lpm	r20, Z
    2048:	e7 fc       	sbrc	r14, 7
    204a:	40 81       	ld	r20, Z
    204c:	4d 93       	st	X+, r20
    204e:	4f ef       	ldi	r20, 0xFF	; 255
    2050:	c4 1a       	sub	r12, r20
    2052:	d4 0a       	sbc	r13, r20
    2054:	e4 0a       	sbc	r14, r20
    2056:	f3 cf       	rjmp	.-26     	; 0x203e <memcpy+0x10>
    2058:	ef 90       	pop	r14
    205a:	df 90       	pop	r13
    205c:	cf 90       	pop	r12
    205e:	08 95       	ret

Disassembly of section .text._Exit:

00002240 <_Exit>:
    2240:	0e 94 5e 00 	call	0xbc	; 0xbc <_exit>
